<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../scineplex.css">
<title>Pod::Simple::Subclassing -- write a formatter as a Pod::Simple subclass</title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>


<!-- INDEX BEGIN -->
<div name="index">
<script>writelinks('__top__',3);</script>
<h1><a>Pod::Simple::Subclassing -- write a formatter as a Pod::Simple subclass</a></h1>
<p><a name="__index__"></a></p>


<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#events">Events</a></li>
	<li><a href="#more_pod__simple_methods">More Pod::Simple Methods</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#copyright_and_disclaimers">COPYRIGHT AND DISCLAIMERS</a></li>
	<li><a href="#author">AUTHOR</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Pod::Simple::Subclassing -- write a formatter as a Pod::Simple subclass</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  <span class="keyword">package</span> <span class="variable">Pod::SomeFormatter</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">Pod::Simple</span><span class="operator">;</span>
  <span class="variable">@ISA</span> <span class="operator">=</span> <span class="string">qw(Pod::Simple)</span><span class="operator">;</span>
  <span class="variable">$VERSION</span> <span class="operator">=</span> <span class="string">'1.01'</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">strict</span><span class="operator">;</span>
</pre>
<pre>
  <span class="keyword">sub</span><span class="variable"> _handle_element_start </span><span class="operator">{</span>
    <span class="keyword">my</span><span class="operator">(</span><span class="variable">$parser</span><span class="operator">,</span> <span class="variable">$element_name</span><span class="operator">,</span> <span class="variable">$attr_hash_r</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
    <span class="operator">...</span>
  <span class="operator">}</span>
</pre>
<pre>
  <span class="keyword">sub</span><span class="variable"> _handle_element_end </span><span class="operator">{</span>
    <span class="keyword">my</span><span class="operator">(</span><span class="variable">$parser</span><span class="operator">,</span> <span class="variable">$element_name</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
    <span class="operator">...</span>
  <span class="operator">}</span>
</pre>
<pre>
  <span class="keyword">sub</span><span class="variable"> _handle_text </span><span class="operator">{</span>
    <span class="keyword">my</span><span class="operator">(</span><span class="variable">$parser</span><span class="operator">,</span> <span class="variable">$text</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
    <span class="operator">...</span>
  <span class="operator">}</span>
  <span class="number">1</span><span class="operator">;</span>
</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>This document is about using Pod::Simple to write a Pod processor,
generally a Pod formatter. If you just want to know about using an
existing Pod formatter, instead see its documentation and see also the
docs in <a href="../../../lib/Pod/Simple.html">the Pod::Simple manpage</a>.</p>
<p>The zeroeth step in writing a Pod formatter is to make sure that there
isn't already a decent one in CPAN. See <a href="http://search.cpan.org/">http://search.cpan.org/</a>, and
run a search on the name of the format you want to render to. Also
consider joining the Pod People list
<a href="http://lists.perl.org/showlist.cgi?name=pod-people">http://lists.perl.org/showlist.cgi</a> and asking whether
anyone has a formatter for that format -- maybe someone cobbled one
together but just hasn't released it.</p>
<p>The first step in writing a Pod processor is to read <a href="../../../lib/perlpodspec.html">the perlpodspec manpage</a>,
which contains notes information on writing a Pod parser (which has been
largely taken care of by Pod::Simple), but also a lot of requirements
and recommendations for writing a formatter.</p>
<p>The second step is to actually learn the format you're planning to
format to -- or at least as much as you need to know to represent Pod,
which probably isn't much.</p>
<p>The third step is to pick which of Pod::Simple's interfaces you want to
use -- the basic interface via Pod::Simple or <a href="../../../lib/Pod/Simple/Methody.html">the Pod::Simple::Methody manpage</a> is
event-based, sort of like <a href="../../../lib/HTML/Parser.html">the HTML::Parser manpage</a>'s interface, or sort of like
<a href="../../../lib/XML/Parser.html">the XML::Parser manpage</a>'s &quot;Handlers&quot; interface), but <a href="../../../lib/Pod/Simple/PullParser.html">the Pod::Simple::PullParser manpage</a>
provides a token-stream interface, sort of like <a href="../../../lib/HTML/TokeParser.html">the HTML::TokeParser manpage</a>'s
interface; <a href="../../../lib/Pod/Simple/SimpleTree.html">the Pod::Simple::SimpleTree manpage</a> provides a simple tree interface,
rather like XML::Parser's &quot;Tree&quot; interface. Users familiar with
XML-handling will find one of these styles relatively familiar; but if
you would be even more at home with XML, there are classes that produce
an XML representation of the Pod stream, notably
<a href="../../../lib/Pod/Simple/XMLOutStream.html">the Pod::Simple::XMLOutStream manpage</a>; you can feed the output of such a class to
whatever XML parsing system you are most at home with.</p>
<p>The last step is to write your code based on how the events (or tokens,
or tree-nodes, or the XML, or however you're parsing) will map to
constructs in the output format. Also sure to consider how to escape
text nodes containing arbitrary text, and also what to do with text
nodes that represent preformatted text (from verbatim sections).</p>
<p>
</p>
<hr />
<h1><a name="events">Events</a></h1>
<p>TODO intro... mention that events are supplied for implicits, like for
missing &gt;'s</p>
<p>In the following section, we use XML to represent the event structure
associated with a particular construct.  That is, TODO</p>
<dl>
<dt><strong><a name="_handle_element_start" class="item"><code>$parser-&gt;_handle_element_start( element_name, attr_hashref )</code></a></strong>

<dt><strong><a name="_handle_element_end" class="item"><code>$parser-&gt;_handle_element_end( element_name  )</code></a></strong>

<dt><strong><a name="_handle_text" class="item"><code>$parser-&gt;_handle_text(  text_string  )</code></a></strong>

</dl>
<p>TODO describe</p>
<dl>
<dt><strong><a name="events_with_an_element_name_of_document" class="item">events with an element_name of Document</a></strong>

<dd>
<p>Parsing a document produces this event structure:</p>
</dd>
<dd>
<pre>
  &lt;Document start_line=&quot;543&quot;&gt;
    ...all events...
  &lt;/Document&gt;</pre>
</dd>
<dd>
<p>The value of the <em>start_line</em> attribute will be the line number of the first
Pod directive in the document.</p>
</dd>
<dd>
<p>If there is no Pod in the given document, then the 
event structure will be this:</p>
</dd>
<dd>
<pre>
  &lt;Document contentless=&quot;1&quot; start_line=&quot;543&quot;&gt;
  &lt;/Document&gt;</pre>
</dd>
<dd>
<p>In that case, the value of the <em>start_line</em> attribute will not be meaningful;
under current implementations, it will probably be the line number of the
last line in the file.</p>
</dd>
</li>
<dt><strong><a name="events_with_an_element_name_of_para" class="item">events with an element_name of Para</a></strong>

<dd>
<p>Parsing a plain (non-verbatim, non-directive, non-data) paragraph in
a Pod document produces this event structure:</p>
</dd>
<dd>
<pre>
    &lt;Para start_line=&quot;543&quot;&gt;
      ...all events in this paragraph...
    &lt;/Para&gt;</pre>
</dd>
<dd>
<p>The value of the <em>start_line</em> attribute will be the line number of the start
of the paragraph.</p>
</dd>
<dd>
<p>For example, parsing this paragraph of Pod:</p>
</dd>
<dd>
<pre>
  The value of the I&lt;start_line&gt; attribute will be the
  line number of the start of the paragraph.</pre>
</dd>
<dd>
<p>produces this event structure:</p>
</dd>
<dd>
<pre>
    &lt;Para start_line=&quot;129&quot;&gt;
      The value of the 
      &lt;I&gt;
        start_line
      &lt;/I&gt;
       attribute will be the line number of the first Pod directive
      in the document.
    &lt;/Para&gt;</pre>
</dd>
</li>
<dt><strong><a name="events_with_an_element_name_of_b_c_f_or_i" class="item">events with an element_name of B, C, F, or I.</a></strong>

<dd>
<p>Parsing a B&lt;...&gt; formatting code (or of course any of its
semantically identical syntactic variants
B&lt;&lt;&nbsp;...&nbsp;&gt;&gt;,
or B&lt;&lt;&lt;&lt;&nbsp;...&nbsp;&gt;&gt;&gt;&gt;, etc.)
produces this event structure:</p>
</dd>
<dd>
<pre>
      &lt;B&gt;
        ...stuff...
      &lt;/B&gt;</pre>
</dd>
<dd>
<p>Currently, there are no attributes conveyed.</p>
</dd>
<dd>
<p>Parsing C, F, or I codes produce the same structure, with only a
different element name.</p>
</dd>
<dd>
<p>If your parser object has been set to accept other formatting codes,
then they will be presented like these B/C/F/I codes -- i.e., without
any attributes.</p>
</dd>
</li>
<dt><strong><a name="events_with_an_element_name_of_s" class="item">events with an element_name of S</a></strong>

<dd>
<p>Normally, parsing an S&lt;...&gt; sequence produces this event
structure, just as if it were a B/C/F/I code:</p>
</dd>
<dd>
<pre>
      &lt;S&gt;
        ...stuff...
      &lt;/S&gt;</pre>
</dd>
<dd>
<p>However, Pod::Simple (and presumably all derived parsers) offers the
<a href="#nbsp_for_s"><code>nbsp_for_S</code></a> option which, if enabled, will suppress all S events, and
instead change all spaces in the content to non-breaking spaces. This is
intended for formatters that output to a format that has no code that
means the same as S&lt;...&gt;, but which has a code/character that
means non-breaking space.</p>
</dd>
</li>
<dt><strong><a name="events_with_an_element_name_of_x" class="item">events with an element_name of X</a></strong>

<dd>
<p>Normally, parsing an X&lt;...&gt; sequence produces this event
structure, just as if it were a B/C/F/I code:</p>
</dd>
<dd>
<pre>
      &lt;X&gt;
        ...stuff...
      &lt;/X&gt;</pre>
</dd>
<dd>
<p>However, Pod::Simple (and presumably all derived parsers) offers the
<a href="#nix_x_codes"><code>nix_X_codes</code></a> option which, if enabled, will suppress all X events
and ignore their content.  For formatters/processors that don't use
X events, this is presumably quite useful.</p>
</dd>
</li>
<dt><strong><a name="events_with_an_element_name_of_l" class="item">events with an element_name of L</a></strong>

<dd>
<p>Because the L&lt;...&gt; is the most complex construct in the
language, it should not surprise you that the events it generates are
the most complex in the language. Most of complexity is hidden away in
the attribute values, so for those of you writing a Pod formatter that
produces a non-hypertextual format, you can just ignore the attributes
and treat an L event structure like a formatting element that
(presumably) doesn't actually produce a change in formatting.  That is,
the content of the L event structure (as opposed to its
attributes) is always what text should be displayed.</p>
</dd>
<dd>
<p>There are, at first glance, three kinds of L links: URL, man, and pod.</p>
</dd>
<dd>
<p>When a L&lt;<em>some_url</em>&gt; code is parsed, it produces this event
structure:</p>
</dd>
<dd>
<pre>
  &lt;L content-implicit=&quot;yes&quot; to=&quot;that_url&quot; type=&quot;url&quot;&gt;
    that_url
  &lt;/L&gt;</pre>
</dd>
<dd>
<p>The <code>type=&quot;url&quot;</code> attribute is always specified for this type of
L code.</p>
</dd>
<dd>
<p>For example, this Pod source:</p>
</dd>
<dd>
<pre>
  L&lt;<a href="http://www.perl.com/CPAN/authors/&gt">http://www.perl.com/CPAN/authors/&gt</a>;</pre>
</dd>
<dd>
<p>produces this event structure:</p>
</dd>
<dd>
<pre>
  &lt;L content-implicit=&quot;yes&quot; to=&quot;<a href="http://www.perl.com/CPAN/authors/&quot">http://www.perl.com/CPAN/authors/&quot</a>; type=&quot;url&quot;&gt;
    <a href="http://www.perl.com/CPAN/authors/">http://www.perl.com/CPAN/authors/</a>
  &lt;/L&gt;</pre>
</dd>
<dd>
<p>When a L&lt;<em>manpage(section)</em>&gt; code is parsed (and these are
fairly rare and not terribly useful), it produces this event structure:</p>
</dd>
<dd>
<pre>
  &lt;L content-implicit=&quot;yes&quot; to=&quot;manpage(section)&quot; type=&quot;man&quot;&gt;
    manpage(section)
  &lt;/L&gt;</pre>
</dd>
<dd>
<p>The <code>type=&quot;man&quot;</code> attribute is always specified for this type of
L code.</p>
</dd>
<dd>
<p>For example, this Pod source:</p>
</dd>
<dd>
<pre>
  L&lt;crontab(5)&gt;</pre>
</dd>
<dd>
<p>produces this event structure:</p>
</dd>
<dd>
<pre>
  &lt;L content-implicit=&quot;yes&quot; to=&quot;crontab(5)&quot; type=&quot;man&quot;&gt;
    crontab(5)
  &lt;/L&gt;</pre>
</dd>
<dd>
<p>In the rare cases where a man page link has a specified, that text appears
in a <em>section</em> attribute. For example, this Pod source:</p>
</dd>
<dd>
<pre>
  L&lt;crontab(5)/&quot;ENVIRONMENT&quot;&gt;</pre>
</dd>
<dd>
<p>will produce this event structure:</p>
</dd>
<dd>
<pre>
  &lt;L content-implicit=&quot;yes&quot; section=&quot;ENVIRONMENT&quot; to=&quot;crontab(5)&quot; type=&quot;man&quot;&gt;
    &quot;ENVIRONMENT&quot; in crontab(5)
  &lt;/L&gt;</pre>
</dd>
<dd>
<p>In the rare case where the Pod document has code like
L&lt;<em>sometext</em>|<em>manpage(section)</em>&gt;, then the <em>sometext</em> will appear
as the content of the element, the <em>manpage(section)</em> text will appear
only as the value of the <em>to</em> attribute, and there will be no
<code>content-implicit=&quot;yes&quot;</code> attribute (whose presence means that the Pod parser
had to infer what text should appear as the link text -- as opposed to
cases where that attribute is absent, which means that the Pod parser did
<em>not</em> have to infer the link text, because that L code explicitly specified
some link text.)</p>
</dd>
<dd>
<p>For example, this Pod source:</p>
</dd>
<dd>
<pre>
  L&lt;hell itself!|crontab(5)&gt;
  
will produce this event structure:</pre>
</dd>
<dd>
<pre>
  &lt;L to=&quot;crontab(5)&quot; type=&quot;man&quot;&gt;
    hell itself!
  &lt;/L&gt;</pre>
</dd>
<dd>
<p>The last type of L structure is for links to/within Pod documents. It is
the most complex because it can have a <em>to</em> attribute, <em>or</em> a
<em>section</em> attribute, or both. The <code>type=&quot;pod&quot;</code> attribute is always
specified for this type of L code.</p>
</dd>
<dd>
<p>In the most common case, the simple case of a L&lt;podpage&gt; code
produces this event structure:</p>
</dd>
<dd>
<pre>
  &lt;L content-implicit=&quot;yes&quot; to=&quot;Net::Ping&quot; type=&quot;pod&quot;&gt;
    podpage
  &lt;/L&gt;</pre>
</dd>
<dd>
<p>For example, this Pod source:</p>
</dd>
<dd>
<pre>
  L&lt;Net::Ping&gt;</pre>
</dd>
<dd>
<p>produces this event structure:</p>
</dd>
<dd>
<pre>
  &lt;L content-implicit=&quot;yes&quot; to=&quot;Net::Ping&quot; type=&quot;pod&quot;&gt;
    Net::Ping
  &lt;/L&gt;</pre>
</dd>
<dd>
<p>In cases where there is link-text explicitly specified, it
is to be found in the content of the element (and not the
attributes), just as with the L&lt;<em>sometext</em>|<em>manpage(section)</em>&gt;
case discussed above.  For example, this Pod source:</p>
</dd>
<dd>
<pre>
  L&lt;Perl Error Messages|<a href="../../../lib/pods/perldiag.html">perldiag</a>&gt;</pre>
</dd>
<dd>
<p>produces this event structure:</p>
</dd>
<dd>
<pre>
  &lt;L to=&quot;<a href="../../../lib/pods/perldiag.html">perldiag</a>&quot; type=&quot;pod&quot;&gt;
    Perl Error Messages
  &lt;/L&gt;</pre>
</dd>
<dd>
<p>In cases of links to a section in the current Pod document,
there is a <em>section</em> attribute instead of a <em>to</em> attribute.
For example, this Pod source:</p>
</dd>
<dd>
<pre>
  L&lt;/&quot;Member Data&quot;&gt;</pre>
</dd>
<dd>
<p>produces this event structure:</p>
</dd>
<dd>
<pre>
  &lt;L content-implicit=&quot;yes&quot; section=&quot;Member Data&quot; type=&quot;pod&quot;&gt;
    &quot;Member Data&quot;
  &lt;/L&gt;</pre>
</dd>
<dd>
<p>As another example, this Pod source:</p>
</dd>
<dd>
<pre>
  L&lt;the various attributes|/&quot;Member Data&quot;&gt;</pre>
</dd>
<dd>
<p>produces this event structure:</p>
</dd>
<dd>
<pre>
  &lt;L section=&quot;Member Data&quot; type=&quot;pod&quot;&gt;
    the various attributes
  &lt;/L&gt;</pre>
</dd>
<dd>
<p>In cases of links to a section in a different Pod document,
there are both a <em>section</em> attribute and a <em>to</em> attribute.
For example, this Pod source:</p>
</dd>
<dd>
<pre>
  L&lt;<a href="../../../lib/pods/perlsyn.html">perlsyn</a>/&quot;Basic BLOCKs and Switch Statements&quot;&gt;</pre>
</dd>
<dd>
<p>produces this event structure:</p>
</dd>
<dd>
<pre>
  &lt;L content-implicit=&quot;yes&quot; section=&quot;Basic BLOCKs and Switch Statements&quot; to=&quot;<a href="../../../lib/pods/perlsyn.html">perlsyn</a>&quot; type=&quot;pod&quot;&gt;
    &quot;Basic BLOCKs and Switch Statements&quot; in <a href="../../../lib/pods/perlsyn.html">perlsyn</a>
  &lt;/L&gt;</pre>
</dd>
<dd>
<p>As another example, this Pod source:</p>
</dd>
<dd>
<pre>
  L&lt;SWITCH statements|<a href="../../../lib/pods/perlsyn.html">perlsyn</a>/&quot;Basic BLOCKs and Switch Statements&quot;&gt;</pre>
</dd>
<dd>
<p>produces this event structure:</p>
</dd>
<dd>
<pre>
  &lt;L section=&quot;Basic BLOCKs and Switch Statements&quot; to=&quot;<a href="../../../lib/pods/perlsyn.html">perlsyn</a>&quot; type=&quot;pod&quot;&gt;
    SWITCH statements
  &lt;/L&gt;</pre>
</dd>
<dd>
<p>Incidentally, note that we do not distinguish between these syntaxes:</p>
</dd>
<dd>
<pre>
  L&lt;/&quot;Member Data&quot;&gt;
  L&lt;&quot;Member Data&quot;&gt;
  L&lt;/Member Data&gt;
  L&lt;Member Data&gt;    [deprecated syntax]</pre>
</dd>
<dd>
<p>That is, they all produce the same event structure, namely:</p>
</dd>
<dd>
<pre>
  <span class="operator">&lt;</span><span class="variable">L</span> <span class="variable">content</span><span class="operator">-</span><span class="variable">implicit</span><span class="operator">=</span><span class="string">"yes"</span> <span class="variable">section</span><span class="operator">=</span><span class="string">"Member Data"</span> <span class="variable">type</span><span class="operator">=</span><span class="string">"pod"</span><span class="operator">&gt;</span>
    <span class="operator">&amp;</span><span class="comment">#34;Member Data&amp;#34;</span>
  <span class="operator">&lt;/</span><span class="variable">L</span><span class="operator">&gt;</span>
</pre>
</dd>
</li>
<dt><strong><a name="events_with_an_element_name_of_e_or_z" class="item">events with an element_name of E or Z</a></strong>

<dd>
<p>While there are Pod codes E&lt;...&gt; and Z&lt;&gt;, these
<em>do not</em> produce any E or Z events -- that is, there are no such
events as E or Z.</p>
</dd>
</li>
<dt><strong><a name="events_with_an_element_name_of_verbatim" class="item">events with an element_name of Verbatim</a></strong>

<dd>
<p>When a Pod verbatim paragraph (AKA &quot;codeblock&quot;) is parsed, it
produces this event structure:</p>
</dd>
<dd>
<pre>
  &lt;Verbatim start_line=&quot;543&quot; xml:space=&quot;preserve&quot;&gt;
    ...text...
  &lt;/Verbatim&gt;</pre>
</dd>
<dd>
<p>The value of the <em>start_line</em> attribute will be the line number of the
first line of this verbatim block.  The <em>xml:space</em> attribute is always
present, and always has the value &quot;preserve&quot;.</p>
</dd>
<dd>
<p>The text content will have tabs already expanded.</p>
</dd>
</li>
<dt><strong><a name="events_with_an_element_name_of_head1_head4" class="item">events with an element_name of head1 .. head4</a></strong>

<dd>
<p>When a &quot;=head1 ...&quot; directive is parsed, it produces this event
structure:</p>
</dd>
<dd>
<pre>
  &lt;head1&gt;
    ...stuff...
  &lt;/head1&gt;</pre>
</dd>
<dd>
<p>For example, a directive consisting of this:</p>
</dd>
<dd>
<pre>
  =head1 Options to C&lt;new&gt; et al.</pre>
</dd>
<dd>
<p>will produce this event structure:</p>
</dd>
<dd>
<pre>
  &lt;head1 start_line=&quot;543&quot;&gt;
    Options to 
    &lt;C&gt;
      new
    &lt;/C&gt;
     et al.
  &lt;/head1&gt;</pre>
</dd>
<dd>
<p>&quot;=head2&quot; thru &quot;=head4&quot; directives are the same, except for the element
names in the event structure.</p>
</dd>
</li>
<dt><strong><a name="events_with_an_element_name_of_over_bullet" class="item">events with an element_name of over-bullet</a></strong>

<dd>
<p>When an &quot;=over ... =back&quot; block is parsed where the items are
a bulletted list, it will produce this event structure:</p>
</dd>
<dd>
<pre>
  &lt;over-bullet indent=&quot;4&quot; start_line=&quot;543&quot;&gt;
    &lt;item-bullet start_line=&quot;545&quot;&gt;
      ...Stuff...
    &lt;/item-bullet&gt;
    ...more item-bullets...
  &lt;/over-bullet&gt;</pre>
</dd>
<dd>
<p>The value of the <em>indent</em> attribute is whatever value is after the
&quot;=over&quot; directive, as in &quot;=over 8&quot;.  If no such value is specified
in the directive, then the <em>indent</em> attribute has the value &quot;4&quot;.</p>
</dd>
<dd>
<p>For example, this Pod source:</p>
</dd>
<dd>
<pre>
  =over</pre>
</dd>
<dd>
<pre>
  =item *</pre>
</dd>
<dd>
<pre>
  Stuff</pre>
</dd>
<dd>
<pre>
  =item *</pre>
</dd>
<dd>
<pre>
  Bar I&lt;baz&gt;!</pre>
</dd>
<dd>
<pre>
  =back</pre>
</dd>
<dd>
<p>produces this event structure:</p>
</dd>
<dd>
<pre>
  &lt;over-bullet indent=&quot;4&quot; start_line=&quot;10&quot;&gt;
    &lt;item-bullet start_line=&quot;12&quot;&gt;
      Stuff
    &lt;/item-bullet&gt;
    &lt;item-bullet start_line=&quot;14&quot;&gt;
      Bar &lt;I&gt;baz&lt;/I&gt;!
    &lt;/item-bullet&gt;
  &lt;/over-bullet&gt;</pre>
</dd>
</li>
<dt><strong><a name="events_with_an_element_name_of_over_number" class="item">events with an element_name of over-number</a></strong>

<dd>
<p>When an &quot;=over ... =back&quot; block is parsed where the items are
a numbered list, it will produce this event structure:</p>
</dd>
<dd>
<pre>
  &lt;over-number indent=&quot;4&quot; start_line=&quot;543&quot;&gt;
    &lt;item-number number=&quot;1&quot; start_line=&quot;545&quot;&gt;
      ...Stuff...
    &lt;/item-number&gt;
    ...more item-number...
  &lt;/over-bullet&gt;</pre>
</dd>
<dd>
<p>This is like the &quot;over-bullet&quot; event structure; but note that the contents
are &quot;item-number&quot; instead of &quot;item-bullet&quot;, and note that they will have
a &quot;number&quot; attribute, which some formatters/processors may ignore
(since, for example, there's no need for it in HTML when producing
an &quot;&lt;UL&gt;&lt;LI&gt;...&lt;/LI&gt;...&lt;/UL&gt;&quot; structure), but which any processor may use.</p>
</dd>
<dd>
<p>Note that the values for the <em>number</em> attributes of &quot;item-number&quot;
elements in a given &quot;over-number&quot; area <em>will</em> start at 1 and go up by
one each time.  If the Pod source doesn't follow that order (even though
it really should should!), whatever numbers it has will be ignored (with
the correct values being put in the <em>number</em> attributes), and an error
message might be issued to the user.</p>
</dd>
</li>
<dt><strong><a name="events_with_an_element_name_of_over_text" class="item">events with an element_name of over-text</a></strong>

<dd>
<p>These events are are somewhat unlike the other over-*
structures, as far as what their contents are.  When
an &quot;=over ... =back&quot; block is parsed where the items are
a list of text &quot;subheadings&quot;, it will produce this event structure:</p>
</dd>
<dd>
<pre>
  &lt;over-text indent=&quot;4&quot; start_line=&quot;543&quot;&gt;
    &lt;item-text&gt;
      ...stuff...
    &lt;/item-text&gt;
    ...stuff (generally Para or Verbatim elements)...
    &lt;item-text&gt;
    ...more item-text and/or stuff...
  &lt;/over-text&gt;</pre>
</dd>
<dd>
<p>The <em>indent</em> attribute is as with the other over-* events.</p>
</dd>
<dd>
<p>For example, this Pod source:</p>
</dd>
<dd>
<pre>
  =over
  
  =item Foo
  
  Stuff
  
  =item Bar I&lt;baz&gt;!
  
  Quux
  
  =back</pre>
</dd>
<dd>
<p>produces this event structure:</p>
</dd>
<dd>
<pre>
  &lt;over-text indent=&quot;4&quot; start_line=&quot;20&quot;&gt;
    &lt;item-text start_line=&quot;22&quot;&gt;
      Foo
    &lt;/item-text&gt;
    &lt;Para start_line=&quot;24&quot;&gt;
      Stuff
    &lt;/Para&gt;
    &lt;item-text start_line=&quot;26&quot;&gt;
      Bar
        &lt;I&gt;
          baz
        &lt;/I&gt;
      !
    &lt;/item-text&gt;
    &lt;Para start_line=&quot;28&quot;&gt;
      Quux
    &lt;/Para&gt;
  &lt;/over-text&gt;</pre>
</dd>
</li>
<dt><strong><a name="events_with_an_element_name_of_over_block" class="item">events with an element_name of over-block</a></strong>

<dd>
<p>These events are are somewhat unlike the other over-*
structures, as far as what their contents are.  When
an &quot;=over ... =back&quot; block is parsed where there are no items,
it will produce this event structure:</p>
</dd>
<dd>
<pre>
  &lt;over-block indent=&quot;4&quot; start_line=&quot;543&quot;&gt;
    ...stuff (generally Para or Verbatim elements)...
  &lt;/over-block&gt;</pre>
</dd>
<dd>
<p>The <em>indent</em> attribute is as with the other over-* events.</p>
</dd>
<dd>
<p>For example, this Pod source:</p>
</dd>
<dd>
<pre>
  =over
  
  For cutting off our trade with all parts of the world
  
  For transporting us beyond seas to be tried for pretended offenses
  
  He is at this time transporting large armies of foreign mercenaries to
  complete the works of death, desolation and tyranny, already begun with
  circumstances of cruelty and perfidy scarcely paralleled in the most
  barbarous ages, and totally unworthy the head of a civilized nation.
  
  =cut
  
will produce this event structure:</pre>
</dd>
<dd>
<pre>
  &lt;over-block indent=&quot;4&quot; start_line=&quot;2&quot;&gt;
    &lt;Para start_line=&quot;4&quot;&gt;
      For cutting off our trade with all parts of the world
    &lt;/Para&gt;
    &lt;Para start_line=&quot;6&quot;&gt;
      For transporting us beyond seas to be tried for pretended offenses
    &lt;/Para&gt;
    &lt;Para start_line=&quot;8&quot;&gt;
      He is at this time transporting large armies of [...more text...]
    &lt;/Para&gt;
  &lt;/over-block&gt;</pre>
</dd>
</li>
<dt><strong><a name="events_with_an_element_name_of_item_bullet" class="item">events with an element_name of item-bullet</a></strong>

<dd>
<p>See <a href="#events_with_an_element_name_of_over_bullet">events with an element_name of over-bullet</a>, above.</p>
</dd>
</li>
<dt><strong><a name="events_with_an_element_name_of_item_number" class="item">events with an element_name of item-number</a></strong>

<dd>
<p>See <a href="#events_with_an_element_name_of_over_number">events with an element_name of over-number</a>, above.</p>
</dd>
</li>
<dt><strong><a name="events_with_an_element_name_of_item_text" class="item">events with an element_name of item-text</a></strong>

<dd>
<p>See <a href="#events_with_an_element_name_of_over_text">events with an element_name of over-text</a>, above.</p>
</dd>
</li>
<dt><strong><a name="events_with_an_element_name_of_for" class="item">events with an element_name of for</a></strong>

<dd>
<p>TODO...</p>
</dd>
</li>
<dt><strong><a name="events_with_an_element_name_of_data" class="item">events with an element_name of Data</a></strong>

<dd>
<p>TODO...</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="more_pod__simple_methods">More Pod::Simple Methods</a></h1>
<p>Pod::Simple provides a lot of methods that aren't generally interesting
to the end user of an existing Pod formatter, but some of which you
might find useful in writing a Pod formatter. They are listed below. The
first several methods (the accept_* methods) are for declaring the
capabilites of your parser, notably what <code>=for targetname</code> sections
it's interested in, what extra N&lt;...&gt; codes it accepts beyond
the ones described in the <em>perlpod</em>.</p>
<dl>
<dt><strong><a name="accept_targets" class="item"><code>$parser-&gt;accept_targets( SOMEVALUE )</code></a></strong>

<dd>
<p>As the parser sees sections like:</p>
</dd>
<dd>
<pre>
    =for html  &lt;img src=&quot;fig1.jpg&quot;&gt;</pre>
</dd>
<dd>
<p>or</p>
</dd>
<dd>
<pre>
    =begin html</pre>
</dd>
<dd>
<pre>
      &lt;img src=&quot;fig1.jpg&quot;&gt;</pre>
</dd>
<dd>
<pre>
    =end html</pre>
</dd>
<dd>
<p>...the parser will ignore these sections unless your subclass has
specified that it wants to see sections targetted to &quot;html&quot; (or whatever
the formatter name is).</p>
</dd>
<dd>
<p>If you want to process all sections, even if they're not targetted for you,
call this before you start parsing:</p>
</dd>
<dd>
<pre>
  <span class="variable">$parser</span><span class="operator">-&gt;</span><span class="variable">accept_targets</span><span class="operator">(</span><span class="string">'*'</span><span class="operator">);</span>
</pre>
</dd>
</li>
<dt><strong><a name="accept_targets_as_text" class="item"><code>$parser-&gt;accept_targets_as_text(  SOMEVALUE  )</code></a></strong>

<dd>
<p>This is like accept_targets, except that it specifies also that the
content of sections for this target should be treated as Pod text even
if the target name in &quot;=for <em>targetname</em>&quot; doesn't start with a &quot;:&quot;.</p>
</dd>
<dd>
<p>At time of writing, I don't think you'll need to use this.</p>
</dd>
</li>
<dt><strong><a name="accept_codes" class="item"><code>$parser-&gt;accept_codes( Codename, Codename...  )</code></a></strong>

<dd>
<p>This tells the parser that you accept additional formatting codes,
beyond just the standard ones (I B C L F S X, plus the two weird ones
you don't actually see in the parse tree, Z and E). For example, to also
accept codes &quot;N&quot;, &quot;R&quot;, and &quot;W&quot;:</p>
</dd>
<dd>
<pre>
    <span class="variable">$parser</span><span class="operator">-&gt;</span><span class="variable">accept_codes</span><span class="operator">(</span> <span class="string">qw( N R W )</span> <span class="operator">);</span>
</pre>
</dd>
<dd>
<p><strong>TODO: document how this interacts with =extend, and long element names</strong></p>
</dd>
</li>
<dt><strong><a name="accept_directive_as_data" class="item"><code>$parser-&gt;accept_directive_as_data( directive_name )</code></a></strong>

<dt><strong><a name="accept_directive_as_verbatim" class="item"><code>$parser-&gt;accept_directive_as_verbatim( directive_name )</code></a></strong>

<dt><strong><a name="accept_directive_as_processed" class="item"><code>$parser-&gt;accept_directive_as_processed( directive_name )</code></a></strong>

<dd>
<p>In the unlikely situation that you need to tell the parser that you will
accept additional directives (&quot;=foo&quot; things), you need to first set the
parset to treat its content as data (i.e., not really processed at
all), or as verbatim (mostly just expanding tabs), or as processed text
(parsing formatting codes like B&lt;...&gt;).</p>
</dd>
<dd>
<p>For example, to accept a new directive &quot;=method&quot;, you'd presumably
use:</p>
</dd>
<dd>
<pre>
    <span class="variable">$parser</span><span class="operator">-&gt;</span><span class="variable">accept_directive_as_processed</span><span class="operator">(</span><span class="string">"method"</span><span class="operator">);</span>
</pre>
</dd>
<dd>
<p>so that you could have Pod lines like:</p>
</dd>
<dd>
<pre>
    =method I&lt;$whatever&gt; thing B&lt;um&gt;</pre>
</dd>
<dd>
<p>Making up your own directives breaks compatibility with other Pod
formatters, in a way that using &quot;=for <em>target</em> ...&quot; lines doesn't;
however, you may find this useful if you're making a Pod superset
format where you don't need to worry about compatibility.</p>
</dd>
</li>
<dt><strong><a name="nbsp_for_s" class="item"><code>$parser-&gt;nbsp_for_S( BOOLEAN );</code></a></strong>

<dd>
<p>Setting this attribute to a true value (and by default it is false) will
turn &quot;S&lt;...&gt;&quot; sequences into sequences of words separated by
<code>\xA0</code> (non-breaking space) characters. For example, it will take this:</p>
</dd>
<dd>
<pre>
    I like S&lt;Dutch apple pie&gt;, don't you?</pre>
</dd>
<dd>
<p>and treat it as if it were:</p>
</dd>
<dd>
<pre>
    I like DutchE&lt;nbsp&gt;appleE&lt;nbsp&gt;pie, don't you?</pre>
</dd>
<dd>
<p>This is handy for output formats that don't have anything quite like an
&quot;S&lt;...&gt;&quot; code, but which do have a code for non-breaking space.</p>
</dd>
<dd>
<p>There is currently no method for going the other way; but I can
probably provide one upon request.</p>
</dd>
</li>
<dt><strong><a name="version_report" class="item"><code>$parser-&gt;version_report()</code></a></strong>

<dd>
<p>This returns a string reporting the $VERSION value from your module (and
its classname) as well as the $VERSION value of Pod::Simple.  Note that
<a href="../../../lib/perlpodspec.html">the perlpodspec manpage</a> requires output formats (wherever possible) to note
this detail in a comment in the output format.  For example, for
some kind of SGML output format:</p>
</dd>
<dd>
<pre>
    <span class="keyword">print</span> <span class="variable">OUT</span> <span class="string">"&lt;!-- \n"</span><span class="operator">,</span> <span class="variable">$parser</span><span class="operator">-&gt;</span><span class="variable">version_report</span><span class="operator">,</span> <span class="string">"\n --&gt;"</span><span class="operator">;</span>
</pre>
</dd>
</li>
<dt><strong><a name="pod_para_count" class="item"><code>$parser-&gt;pod_para_count()</code></a></strong>

<dd>
<p>This returns the count of Pod paragraphs seen so far.</p>
</dd>
</li>
<dt><strong><a name="line_count" class="item"><code>$parser-&gt;line_count()</code></a></strong>

<dd>
<p>This is the current line number being parsed. But you might find the
&quot;line_number&quot; event attribute more accurate, when it is present.</p>
</dd>
</li>
<dt><strong><a name="nix_x_codes" class="item"><code>$parser-&gt;nix_X_codes(  SOMEVALUE  )</code></a></strong>

<dd>
<p>This attribute, when set to a true value (and it is false by default)
ignores any &quot;X&lt;...&gt;&quot; sequences in the document being parsed.
Many formats don't actually use the content of these codes, so have
no reason to process them.</p>
</dd>
</li>
<dt><strong><a name="merge_text" class="item"><code>$parser-&gt;merge_text(  SOMEVALUE  )</code></a></strong>

<dd>
<p>This attribute, when set to a true value (and it is false by default)
makes sure that only one event (or token, or node) will be created
for any single contiguous sequence of text.  For example, consider
this somewhat contrived example:</p>
</dd>
<dd>
<pre>
    I just LOVE Z&lt;&gt;hotE&lt;32&gt;apple pie!</pre>
</dd>
<dd>
<p>When that is parsed and events are about to be called on it, it may
actually seem to be four different text events, one right after another:
one event for &quot;I just LOVE &quot;, one for &quot;hot&quot;, one for &quot; &quot;, and one for
&quot;apple pie!&quot;. But if you have merge_text on, then you're guaranteed
that it will be fired as one text event:  &quot;I just LOVE hot apple pie!&quot;.</p>
</dd>
</li>
<dt><strong><a name="code_handler" class="item"><code>$parser-&gt;code_handler(  CODE_REF  )</code></a></strong>

<dd>
<p>This specifies code that should be called when a code line is seen
(i.e., a line outside of the Pod).  Normally this is undef, meaning
that no code should be called.  If you provide a routine, it should
start out like this:</p>
</dd>
<dd>
<pre>
    <span class="keyword">sub</span><span class="variable"> get_code_line </span><span class="operator">{</span>  <span class="comment"># or whatever you'll call it</span>
      <span class="keyword">my</span><span class="operator">(</span><span class="variable">$line</span><span class="operator">,</span> <span class="variable">$line_number</span><span class="operator">,</span> <span class="variable">$parser</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
      <span class="operator">...</span>
    <span class="operator">}</span>
</pre>
</dd>
<dd>
<p>Note, however, that sometimes the Pod events aren't processed in exactly
the same order as the code lines are -- i.e., if you have a file with
Pod, then code, then more Pod, sometimes the code will be processed (via
whatever you have code_handler call) before the all of the preceding Pod
has been processed.</p>
</dd>
</li>
<dt><strong><a name="cut_handler" class="item"><code>$parser-&gt;cut_handler(  CODE_REF  )</code></a></strong>

<dd>
<p>This is just like the code_handler attribute, except that it's for
&quot;=cut&quot; lines, not code lines. The same caveats apply. &quot;=cut&quot; lines are
unlikely to be interesting, but this is included for completeness.</p>
</dd>
</li>
<dt><strong><a name="whine" class="item"><code>$parser-&gt;whine( linenumber, complaint string )</code></a></strong>

<dd>
<p>This notes a problem in the Pod, which will be reported to in the &quot;Pod
Errors&quot; section of the document and/or send to STDERR, depending on the
values of the attributes <a href="#no_whining"><code>no_whining</code></a>, <a href="#no_errata_section"><code>no_errata_section</code></a>, and
<a href="#complain_stderr"><code>complain_stderr</code></a>.</p>
</dd>
</li>
<dt><strong><a name="scream" class="item"><code>$parser-&gt;scream( linenumber, complaint string )</code></a></strong>

<dd>
<p>This notes an error like <a href="#whine"><code>whine</code></a> does, except that it is not
suppressable with <a href="#no_whining"><code>no_whining</code></a>. This should be used only for very
serious errors.</p>
</dd>
</li>
<dt><strong><a name="source_dead" class="item"><code>$parser-&gt;source_dead(1)</code></a></strong>

<dd>
<p>This aborts parsing of the current document, by switching on the flag
that indicates that EOF has been seen.  In particularly drastic cases,
you might want to do this.  It's rather nicer than just calling
<a href="../../../lib/pods/perlfunc.html#die"><code>die</code></a>!</p>
</dd>
</li>
<dt><strong><a name="hide_line_numbers" class="item"><code>$parser-&gt;hide_line_numbers( SOMEVALUE )</code></a></strong>

<dd>
<p>Some subclasses that indescriminately dump event attributes (well,
except for ones beginning with &quot;~&quot;) can use this object attribute for
refraining to dump the &quot;start_line&quot; attribute.</p>
</dd>
</li>
<dt><strong><a name="no_whining" class="item"><code>$parser-&gt;no_whining( SOMEVALUE )</code></a></strong>

<dd>
<p>This attribute, if set to true, will suppress reports of non-fatal
error messages.  The default value is false, meaning that complaints
<em>are</em> reported.  How they get reported depends on the values of
the attributes <a href="#no_errata_section"><code>no_errata_section</code></a> and <a href="#complain_stderr"><code>complain_stderr</code></a>.</p>
</dd>
</li>
<dt><strong><a name="no_errata_section" class="item"><code>$parser-&gt;no_errata_section( SOMEVALUE )</code></a></strong>

<dd>
<p>This attribute, if set to true, will suppress generation of an errata
section.  The default value is false -- i.e., an errata section will be
generated.</p>
</dd>
</li>
<dt><strong><a name="complain_stderr" class="item"><code>$parser-&gt;complain_stderr( SOMEVALUE )</code></a></strong>

<dd>
<p>This attribute, if set to true will send complaints to STDERR.  The
default value is false -- i.e., complaints do not go to STDERR.</p>
</dd>
</li>
<dt><strong><a name="bare_output" class="item"><code>$parser-&gt;bare_output( SOMEVALUE )</code></a></strong>

<dd>
<p>Some formatter subclasses use this as a flag for whether output should
have prologue and epilogue code omitted. For example, setting this to
true for an HTML formatter class should omit the
&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;...&lt;/title&gt;&lt;body&gt;...&quot; prologue and the
&quot;&lt;/body&gt;&lt;/html&gt;&quot; epilogue.</p>
</dd>
<dd>
<p>If you want to set this to true, you should probably also set
<a href="#no_whining"><code>no_whining</code></a> or at least <a href="#no_errata_section"><code>no_errata_section</code></a> to true.</p>
</dd>
</li>
<dt><strong><a name="preserve_whitespace" class="item"><code>$parser-&gt;preserve_whitespace( SOMEVALUE )</code></a></strong>

<dd>
<p>If you set this attribute to a true value, the parser will try to
preserve whitespace in the output.  This means that such formatting
conventions as two spaces after periods will be preserved by the parser.
This is primarily useful for output formats that treat whitespace as
significant (such as text or *roff, but not HTML).</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p><a href="../../../lib/Pod/Simple.html">the Pod::Simple manpage</a> -- event-based Pod-parsing framework</p>
<p><a href="../../../lib/Pod/Simple/Methody.html">the Pod::Simple::Methody manpage</a> -- like Pod::Simple, but each sort of event
calls its own method (like <code>start_head3</code>)</p>
<p><a href="../../../lib/Pod/Simple/PullParser.html">the Pod::Simple::PullParser manpage</a> -- a Pod-parsing framework like Pod::Simple,
but with a token-stream interface</p>
<p><a href="../../../lib/Pod/Simple/SimpleTree.html">the Pod::Simple::SimpleTree manpage</a> -- a Pod-parsing framework like Pod::Simple,
but with a tree interface</p>
<p><a href="../../../lib/Pod/Simple/Checker.html">the Pod::Simple::Checker manpage</a> -- a simple Pod::Simple subclass that reads
documents, and then makes a plaintext report of any errors found in the
document</p>
<p><a href="../../../lib/Pod/Simple/DumpAsXML.html">the Pod::Simple::DumpAsXML manpage</a> -- for dumping Pod documents as tidily
indented XML, showing each event on its own line</p>
<p><a href="../../../lib/Pod/Simple/XMLOutStream.html">the Pod::Simple::XMLOutStream manpage</a> -- dumps a Pod document as XML (without
introducing extra whitespace as Pod::Simple::DumpAsXML does).</p>
<p><a href="../../../lib/Pod/Simple/DumpAsText.html">the Pod::Simple::DumpAsText manpage</a> -- for dumping Pod documents as tidily
indented text, showing each event on its own line</p>
<p><a href="../../../lib/Pod/Simple/LinkSection.html">the Pod::Simple::LinkSection manpage</a> -- class for objects representing the values
of the TODO and TODO attributes of L&lt;...&gt; elements</p>
<p><a href="../../../lib/Pod/Escapes.html">the Pod::Escapes manpage</a> -- the module the Pod::Simple uses for evaluating
E&lt;...&gt; content</p>
<p><a href="../../../lib/Pod/Simple/Text.html">the Pod::Simple::Text manpage</a> -- a simple plaintext formatter for Pod</p>
<p><a href="../../../lib/Pod/Simple/TextContent.html">the Pod::Simple::TextContent manpage</a> -- like Pod::Simple::Text, but
makes no effort for indent or wrap the text being formatted</p>
<p><a href="../../../lib/perlpod.html">perlpod</a></p>
<p><a href="../../../lib/perlpodspec.html">perlpodspec</a></p>
<p><a href="../../../lib/pods/perldoc.html">the perldoc manpage</a></p>
<p>
</p>
<hr />
<h1><a name="copyright_and_disclaimers">COPYRIGHT AND DISCLAIMERS</a></h1>
<p>Copyright (c) 2002 Sean M. Burke.  All rights reserved.</p>
<p>This library is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<p>This program is distributed in the hope that it will be useful, but
without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.</p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Sean M. Burke <code>sburke@cpan.org</code></p>

</body>

</html>
