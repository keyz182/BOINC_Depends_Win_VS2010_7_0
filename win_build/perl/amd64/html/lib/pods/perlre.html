<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title>perlre - Perl regular expressions</title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>


<!-- INDEX BEGIN -->
<div name="index">
<script>writelinks('__top__',2);</script>
<h1><a>perlre - Perl regular expressions</a></h1>
<p><a name="__index__"></a></p>


<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#modifiers">Modifiers</a></li>
		<li><a href="#regular_expressions">Regular Expressions</a></li>
		<ul>

			<li><a href="#metacharacters">Metacharacters</a></li>
			<li><a href="#quantifiers">Quantifiers</a></li>
			<li><a href="#escape_sequences">Escape sequences</a></li>
			<li><a href="#character_classes_and_other_special_escapes">Character Classes and other Special Escapes</a></li>
			<li><a href="#assertions">Assertions</a></li>
			<li><a href="#capture_buffers">Capture buffers</a></li>
		</ul>

		<li><a href="#extended_patterns">Extended Patterns</a></li>
		<li><a href="#special_backtracking_control_verbs">Special Backtracking Control Verbs</a></li>
		<li><a href="#backtracking">Backtracking</a></li>
		<li><a href="#version_8_regular_expressions">Version 8 Regular Expressions</a></li>
		<li><a href="#warning_on__1_instead_of__1">Warning on \1 Instead of $1</a></li>
		<li><a href="#repeated_patterns_matching_a_zero_length_substring">Repeated Patterns Matching a Zero-length Substring</a></li>
		<li><a href="#combining_re_pieces">Combining RE Pieces</a></li>
		<li><a href="#creating_custom_re_engines">Creating Custom RE Engines</a></li>
	</ul>

	<li><a href="#pcre_python_support">PCRE/Python Support</a></li>
	<li><a href="#bugs">BUGS</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>perlre - Perl regular expressions</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>This page describes the syntax of regular expressions in Perl.</p>
<p>If you haven't used regular expressions before, a quick-start
introduction is available in <a href="../../lib/pods/perlrequick.html">the perlrequick manpage</a>, and a longer tutorial
introduction is available in <a href="../../lib/pods/perlretut.html">the perlretut manpage</a>.</p>
<p>For reference on how regular expressions are used in matching
operations, plus various examples of the same, see discussions of
<a href="../../lib/pods/perlfunc.html#m_"><code>m//</code></a>, <a href="../../lib/pods/perlfunc.html#s_"><code>s///</code></a>, <a href="../../lib/pods/perlfunc.html#qr_"><code>qr//</code></a> and <code>??</code> in <a href="../../lib/pods/perlop.html#regexp_quote_like_operators">Regexp Quote-Like Operators in the perlop manpage</a>.</p>
<p>
</p>
<h2><a name="modifiers">Modifiers</a></h2>
<p>Matching operations can have various modifiers.  Modifiers
that relate to the interpretation of the regular expression inside
are listed below.  Modifiers that alter the way a regular expression
is used by Perl are detailed in <a href="../../lib/pods/perlop.html#regexp_quote_like_operators">Regexp Quote-Like Operators in the perlop manpage</a> and
<a href="../../lib/pods/perlop.html#gory_details_of_parsing_quoted_constructs">Gory details of parsing quoted constructs in the perlop manpage</a>.</p>
<dl>
<dt><strong><a name="m" class="item">m</a></strong>

<dd>
<p>Treat string as multiple lines.  That is, change &quot;^&quot; and &quot;$&quot; from matching
the start or end of the string to matching the start or end of any
line anywhere within the string.</p>
</dd>
</li>
<dt><strong><a name="s" class="item">s</a></strong>

<dd>
<p>Treat string as single line.  That is, change &quot;.&quot; to match any character
whatsoever, even a newline, which normally it would not match.</p>
</dd>
<dd>
<p>Used together, as /ms, they let the &quot;.&quot; match any character whatsoever,
while still allowing &quot;^&quot; and &quot;$&quot; to match, respectively, just after
and just before newlines within the string.</p>
</dd>
</li>
<dt><strong><a name="i" class="item">i</a></strong>

<dd>
<p>Do case-insensitive pattern matching.</p>
</dd>
<dd>
<p>If <code>use locale</code> is in effect, the case map is taken from the current
locale.  See <a href="../../lib/pods/perllocale.html">the perllocale manpage</a>.</p>
</dd>
</li>
<dt><strong><a name="x" class="item">x</a></strong>

<dd>
<p>Extend your pattern's legibility by permitting whitespace and comments.</p>
</dd>
</li>
<dt><strong><a name="p" class="item">p</a></strong>

<dd>
<p>Preserve the string matched such that ${^PREMATCH}, {$^MATCH}, and
${^POSTMATCH} are available for use after matching.</p>
</dd>
</li>
<dt><strong><a name="g_and_c" class="item">g and c</a></strong>

<dd>
<p>Global matching, and keep the Current position after failed matching.
Unlike i, m, s and x, these two flags affect the way the regex is used
rather than the regex itself. See
<a href="../../lib/pods/perlretut.html#using_regular_expressions_in_perl">Using regular expressions in Perl in the perlretut manpage</a> for further explanation
of the g and c modifiers.</p>
</dd>
</li>
</dl>
<p>These are usually written as &quot;the <a href="#x"><code>/x</code></a> modifier&quot;, even though the delimiter
in question might not really be a slash.  Any of these
modifiers may also be embedded within the regular expression itself using
the <code>(?...)</code> construct.  See below.</p>
<p>The <a href="#x"><code>/x</code></a> modifier itself needs a little more explanation.  It tells
the regular expression parser to ignore whitespace that is neither
backslashed nor within a character class.  You can use this to break up
your regular expression into (slightly) more readable parts.  The <code>#</code>
character is also treated as a metacharacter introducing a comment,
just as in ordinary Perl code.  This also means that if you want real
whitespace or <code>#</code> characters in the pattern (outside a character
class, where they are unaffected by <a href="#x"><code>/x</code></a>), then you'll either have to
escape them (using backslashes or <code>\Q...\E</code>) or encode them using octal
or hex escapes.  Taken together, these features go a long way towards
making Perl's regular expressions more readable.  Note that you have to
be careful not to include the pattern delimiter in the comment--perl has
no way of knowing you did not intend to close the pattern early.  See
the C-comment deletion code in <a href="../../lib/pods/perlop.html">the perlop manpage</a>.  Also note that anything inside
a <code>\Q...\E</code> stays unaffected by <a href="#x"><code>/x</code></a>.</p>
<p>
</p>
<h2><a name="regular_expressions">Regular Expressions</a></h2>
<p>
</p>
<h3><a name="metacharacters">Metacharacters</a></h3>
<p>The patterns used in Perl pattern matching evolved from the ones supplied in
the Version 8 regex routines.  (The routines are derived
(distantly) from Henry Spencer's freely redistributable reimplementation
of the V8 routines.)  See <a href="#version_8_regular_expressions">Version 8 Regular Expressions</a> for
details.</p>
<p>In particular the following metacharacters have their standard <em>egrep</em>-ish
meanings:</p>
<pre>
    \   Quote the next metacharacter
    ^   Match the beginning of the line
    .   Match any character (except newline)
    $   Match the end of the line (or before newline at the end)
    |   Alternation
    ()  Grouping
    []  Character class</pre>
<p>By default, the &quot;^&quot; character is guaranteed to match only the
beginning of the string, the &quot;$&quot; character only the end (or before the
newline at the end), and Perl does certain optimizations with the
assumption that the string contains only one line.  Embedded newlines
will not be matched by &quot;^&quot; or &quot;$&quot;.  You may, however, wish to treat a
string as a multi-line buffer, such that the &quot;^&quot; will match after any
newline within the string (except if the newline is the last character in
the string), and &quot;$&quot; will match before any newline.  At the
cost of a little more overhead, you can do this by using the /m modifier
on the pattern match operator.  (Older programs did this by setting <code>$*</code>,
but this practice has been removed in perl 5.9.)</p>
<p>To simplify multi-line substitutions, the &quot;.&quot; character never matches a
newline unless you use the <a href="#s"><code>/s</code></a> modifier, which in effect tells Perl to pretend
the string is a single line--even if it isn't.</p>
<p>
</p>
<h3><a name="quantifiers">Quantifiers</a></h3>
<p>The following standard quantifiers are recognized:</p>
<pre>
    *      Match 0 or more times
    +      Match 1 or more times
    ?      Match 1 or 0 times
    {n}    Match exactly n times
    {n,}   Match at least n times
    {n,m}  Match at least n but not more than m times</pre>
<p>(If a curly bracket occurs in any other context, it is treated
as a regular character.  In particular, the lower bound
is not optional.)  The &quot;*&quot; quantifier is equivalent to <code>{0,}</code>, the &quot;+&quot;
quantifier to <a href="#1"><code>{1,}</code></a>, and the &quot;?&quot; quantifier to <code>{0,1}</code>.  n and m are limited
to integral values less than a preset limit defined when perl is built.
This is usually 32766 on the most common platforms.  The actual limit can
be seen in the error message generated by code such as this:</p>
<pre>
    <span class="variable">$_</span> <span class="operator">**=</span> <span class="variable">$_</span> <span class="operator">,</span> <span class="regex">/ {$_} /</span> <span class="keyword">for</span> <span class="number">2</span> <span class="operator">..</span> <span class="number">42</span><span class="operator">;</span>
</pre>
<p>By default, a quantified subpattern is &quot;greedy&quot;, that is, it will match as
many times as possible (given a particular starting location) while still
allowing the rest of the pattern to match.  If you want it to match the
minimum number of times possible, follow the quantifier with a &quot;?&quot;.  Note
that the meanings don't change, just the &quot;greediness&quot;:</p>
<pre>
    <span class="operator">*</span><span class="regex">?     Match 0 or more times, not greedily
    +?</span>     <span class="variable">Match</span> <span class="number">1</span> <span class="keyword">or</span> <span class="variable">more</span> <span class="keyword">times</span><span class="operator">,</span> <span class="keyword">not</span> <span class="variable">greedily</span>
    <span class="operator">?</span><span class="regex">?     Match 0 or 1 time, not greedily
    {n}?</span>   <span class="variable">Match</span> <span class="variable">exactly</span> <span class="variable">n</span> <span class="keyword">times</span><span class="operator">,</span> <span class="keyword">not</span> <span class="variable">greedily</span>
    <span class="operator">{</span><span class="variable">n</span><span class="operator">,}</span><span class="regex">?  Match at least n times, not greedily
    {n,m}?</span> <span class="variable">Match</span> <span class="variable">at</span> <span class="variable">least</span> <span class="variable">n</span> <span class="variable">but</span> <span class="keyword">not</span> <span class="variable">more</span> <span class="variable">than</span> <span class="regex">m times, not</span> <span class="variable">greedily</span>
</pre>
<p>By default, when a quantified subpattern does not allow the rest of the
overall pattern to match, Perl will backtrack. However, this behaviour is
sometimes undesirable. Thus Perl provides the &quot;possessive&quot; quantifier form
as well.</p>
<pre>
    *+     Match 0 or more times and give nothing back
    ++     Match 1 or more times and give nothing back
    ?+     Match 0 or 1 time and give nothing back
    {n}+   Match exactly n times and give nothing back (redundant)
    {n,}+  Match at least n times and give nothing back
    {n,m}+ Match at least n but not more than m times and give nothing back</pre>
<p>For instance,</p>
<pre>
   'aaaa' =~ /a++a/</pre>
<p>will never match, as the <a href="../../lib/pods/perlrun.html#a"><code>a++</code></a> will gobble up all the <a href="../../lib/pods/perlrun.html#a"><code>a</code></a>'s in the
string and won't leave any for the remaining part of the pattern. This
feature can be extremely useful to give perl hints about where it
shouldn't backtrack. For instance, the typical &quot;match a double-quoted
string&quot; problem can be most efficiently performed when written as:</p>
<pre>
   /&quot;(?:[^&quot;\\]++|\\.)*+&quot;/</pre>
<p>as we know that if the final quote does not match, backtracking will not
help. See the independent subexpression <code>(?&gt;...)</code> for more details;
possessive quantifiers are just syntactic sugar for that construct. For
instance the above example could also be written as follows:</p>
<pre>
   /&quot;(?&gt;(?:(?&gt;[^&quot;\\]+)|\\.)*)&quot;/</pre>
<p>
</p>
<h3><a name="escape_sequences">Escape sequences</a></h3>
<p>Because patterns are processed as double quoted strings, the following
also work:</p>
<pre>
    <span class="operator">\</span><span class="variable">t</span>          <span class="variable">tab</span>                   <span class="operator">(</span><span class="variable">HT</span><span class="operator">,</span> <span class="variable">TAB</span><span class="operator">)</span>
    <span class="operator">\</span><span class="variable">n</span>          <span class="variable">newline</span>               <span class="operator">(</span><span class="variable">LF</span><span class="operator">,</span> <span class="variable">NL</span><span class="operator">)</span>
    <span class="operator">\</span><span class="variable">r</span>          <span class="keyword">return</span>                <span class="operator">(</span><span class="variable">CR</span><span class="operator">)</span>
    <span class="operator">\</span><span class="variable">f</span>          <span class="variable">form</span> <span class="variable">feed</span>             <span class="operator">(</span><span class="variable">FF</span><span class="operator">)</span>
    <span class="operator">\</span><span class="variable">a</span>          <span class="keyword">alarm</span> <span class="operator">(</span><span class="variable">bell</span><span class="operator">)</span>          <span class="operator">(</span><span class="variable">BEL</span><span class="operator">)</span>
    <span class="operator">\</span><span class="variable">e</span>          <span class="variable">escape</span> <span class="operator">(</span><span class="variable">think</span> <span class="variable">troff</span><span class="operator">)</span>  <span class="operator">(</span><span class="variable">ESC</span><span class="operator">)</span>
    <span class="operator">\</span><span class="number">033</span>        <span class="variable">octal</span> <span class="variable">char</span>            <span class="operator">(</span><span class="variable">example</span><span class="operator">:</span> <span class="variable">ESC</span><span class="operator">)</span>
    <span class="operator">\</span><span class="variable">x1B</span>        <span class="keyword">hex</span> <span class="variable">char</span>              <span class="operator">(</span><span class="variable">example</span><span class="operator">:</span> <span class="variable">ESC</span><span class="operator">)</span>
    <span class="operator">\x</span><span class="operator">{</span><span class="string">263a</span><span class="operator">}</span>    <span class="variable">long</span> <span class="keyword">hex</span> <span class="variable">char</span>         <span class="operator">(</span><span class="variable">example</span><span class="operator">:</span> <span class="variable">Unicode</span> <span class="variable">SMILEY</span><span class="operator">)</span>
    <span class="operator">\</span><span class="variable">cK</span>         <span class="variable">control</span> <span class="variable">char</span>          <span class="operator">(</span><span class="variable">example</span><span class="operator">:</span> <span class="variable">VT</span><span class="operator">)</span>
    <span class="operator">\</span><span class="variable">N</span><span class="operator">{</span><span class="variable">name</span><span class="operator">}</span>    <span class="variable">named</span> <span class="variable">Unicode</span> <span class="variable">character</span>
    <span class="operator">\</span><span class="variable">l</span>          <span class="variable">lowercase</span> <span class="keyword">next</span> <span class="variable">char</span> <span class="operator">(</span><span class="variable">think</span> <span class="variable">vi</span><span class="operator">)</span>
    <span class="operator">\</span><span class="variable">u</span>          <span class="variable">uppercase</span> <span class="keyword">next</span> <span class="variable">char</span> <span class="operator">(</span><span class="variable">think</span> <span class="variable">vi</span><span class="operator">)</span>
    <span class="operator">\</span><span class="variable">L</span>          <span class="variable">lowercase</span> <span class="variable">till</span> <span class="operator">\</span><span class="variable">E</span> <span class="operator">(</span><span class="variable">think</span> <span class="variable">vi</span><span class="operator">)</span>
    <span class="operator">\</span><span class="variable">U</span>          <span class="variable">uppercase</span> <span class="variable">till</span> <span class="operator">\</span><span class="variable">E</span> <span class="operator">(</span><span class="variable">think</span> <span class="variable">vi</span><span class="operator">)</span>
    <span class="operator">\</span><span class="variable">E</span>          <span class="variable">end</span> <span class="variable">case</span> <span class="variable">modification</span> <span class="operator">(</span><span class="variable">think</span> <span class="variable">vi</span><span class="operator">)</span>
    <span class="operator">\</span><span class="variable">Q</span>          <span class="variable">quote</span> <span class="operator">(</span><span class="variable">disable</span><span class="operator">)</span> <span class="variable">pattern</span> <span class="variable">metacharacters</span> <span class="variable">till</span> <span class="operator">\</span><span class="variable">E</span>
</pre>
<p>If <code>use locale</code> is in effect, the case map used by <code>\l</code>, <code>\L</code>, <a href="../../lib/pods/perlrun.html#u"><code>\u</code></a>
and <a href="../../lib/pods/perlrun.html#u"><code>\U</code></a> is taken from the current locale.  See <a href="../../lib/pods/perllocale.html">the perllocale manpage</a>.  For
documentation of <code>\N{name}</code>, see <a href="../../lib/charnames.html">the charnames manpage</a>.</p>
<p>You cannot include a literal <code>$</code> or <code>@</code> within a <code>\Q</code> sequence.
An unescaped <code>$</code> or <code>@</code> interpolates the corresponding variable,
while escaping will cause the literal string <code>\$</code> to be matched.
You'll need to write something like <a href="../../lib/pods/perlfunc.html#m_"><code>m/\Quser\E\@\Qhost/</code></a>.</p>
<p>
</p>
<h3><a name="character_classes_and_other_special_escapes">Character Classes and other Special Escapes</a></h3>
<p>In addition, Perl defines the following:</p>
<pre>
    \w       Match a &quot;word&quot; character (alphanumeric plus &quot;_&quot;)
    \W       Match a non-&quot;word&quot; character
    \s       Match a whitespace character
    \S       Match a non-whitespace character
    \d       Match a digit character
    \D       Match a non-digit character
    \pP      Match P, named property.  Use \p{Prop} for longer names.
    \PP      Match non-P
    \X       Match eXtended Unicode &quot;combining character sequence&quot;,
             equivalent to (?:\PM\pM*)
    \C       Match a single C char (octet) even under Unicode.
             NOTE: breaks up characters into their UTF-8 bytes,
             so you may end up with malformed pieces of UTF-8.
             Unsupported in lookbehind.
    \1       Backreference to a specific group.
             '1' may actually be any positive integer.
    \g1      Backreference to a specific or previous group,
    \g{-1}   number may be negative indicating a previous buffer and may
             optionally be wrapped in curly brackets for safer parsing.
    \g{name} Named backreference
    \k&lt;name&gt; Named backreference
    \K       Keep the stuff left of the \K, don't include it in $&amp;
    \v       Vertical whitespace
    \V       Not vertical whitespace
    \h       Horizontal whitespace
    \H       Not horizontal whitespace
    \R       Linebreak</pre>
<p>A <a href="../../lib/pods/perlrun.html#w"><code>\w</code></a> matches a single alphanumeric character (an alphabetic
character, or a decimal digit) or <code>_</code>, not a whole word.  Use <a href="../../lib/pods/perlrun.html#w"><code>\w+</code></a>
to match a string of Perl-identifier characters (which isn't the same
as matching an English word).  If <code>use locale</code> is in effect, the list
of alphabetic characters generated by <a href="../../lib/pods/perlrun.html#w"><code>\w</code></a> is taken from the current
locale.  See <a href="../../lib/pods/perllocale.html">the perllocale manpage</a>.  You may use <a href="../../lib/pods/perlrun.html#w"><code>\w</code></a>, <a href="../../lib/pods/perlrun.html#w"><code>\W</code></a>, <a href="#s"><code>\s</code></a>, <a href="#s"><code>\S</code></a>,
<a href="../../lib/pods/perlrun.html#d"><code>\d</code></a>, and <code>\D</code> within character classes, but they aren't usable
as either end of a range. If any of them precedes or follows a &quot;-&quot;,
the &quot;-&quot; is understood literally. If Unicode is in effect, <a href="#s"><code>\s</code></a> matches
also &quot;\x{85}&quot;, &quot;\x{2028}&quot;, and &quot;\x{2029}&quot;. See <a href="../../lib/pods/perlunicode.html">the perlunicode manpage</a> for more
details about <code>\pP</code>, <code>\PP</code>, <a href="../../lib/pods/perlrun.html#x"><code>\X</code></a> and the possibility of defining
your own <a href="#p"><code>\p</code></a> and <a href="../../lib/pods/perlrun.html#p"><code>\P</code></a> properties, and <a href="../../lib/pods/perluniintro.html">the perluniintro manpage</a> about Unicode
in general.</p>
<p><a href="#r"><code>\R</code></a> will atomically match a linebreak, including the network line-ending
&quot;\x0D\x0A&quot;.  Specifically,  is exactly equivalent to</p>
<pre>
  <span class="operator">(</span><span class="regex">?&gt;\x0D\x0A?</span><span class="operator">|</span><span class="operator">[</span><span class="operator">\</span><span class="variable">x0A</span><span class="operator">-\</span><span class="variable">x0C</span><span class="operator">\</span><span class="variable">x85</span><span class="operator">\x</span><span class="operator">{</span><span class="number">2028</span><span class="operator">}</span><span class="operator">\x</span><span class="operator">{</span><span class="number">2029</span><span class="operator">}]</span><span class="operator">)</span>
</pre>
<p><strong>Note:</strong> <a href="#r"><code>\R</code></a> has no special meaning inside of a character class;
use <a href="../../lib/pods/perlrun.html#v"><code>\v</code></a> instead (vertical whitespace).</p>
<p>The POSIX character class syntax</p>
<pre>
    [:class:]</pre>
<p>is also available.  Note that the <code>[</code> and <code>]</code> brackets are <em>literal</em>;
they must always be used within a character class expression.</p>
<pre>
    <span class="comment"># this is correct:</span>
    <span class="variable">$string</span> <span class="operator">=~</span> <span class="regex">/[[:alpha:]]/</span><span class="operator">;</span>
</pre>
<pre>
    <span class="comment"># this is not, and will generate a warning:</span>
    <span class="variable">$string</span> <span class="operator">=~</span> <span class="regex">/[:alpha:]/</span><span class="operator">;</span>
</pre>
<p>The available classes and their backslash equivalents (if available) are
as follows:</p>
<pre>
    alpha
    alnum
    ascii
    blank               [1]
    cntrl
    digit       \d
    graph
    lower
    print
    punct
    space       \s      [2]
    upper
    word        \w      [3]
    xdigit</pre>
<dl>
<dt><strong><a name="112" class="item">[1]</a></strong>

<dd>
<p>A GNU extension equivalent to <a href="../../lib/pods/perlrun.html#t"><code>[ \t]</code></a>, &quot;all horizontal whitespace&quot;.</p>
</dd>
</li>
<dt><strong><a name="29" class="item">[2]</a></strong>

<dd>
<p>Not exactly equivalent to <a href="#s"><code>\s</code></a> since the <code>[[:space:]]</code> includes
also the (very rare) &quot;vertical tabulator&quot;, &quot;\cK&quot; or chr(11) in ASCII.</p>
</dd>
</li>
<dt><strong><a name="37" class="item">[3]</a></strong>

<dd>
<p>A Perl extension, see above.</p>
</dd>
</li>
</dl>
<p>For example use <code>[:upper:]</code> to match all the uppercase characters.
Note that the <code>[]</code> are part of the <code>[::]</code> construct, not part of the
whole character class.  For example:</p>
<pre>
    [01[:alpha:]%]</pre>
<p>matches zero, one, any alphabetic character, and the percent sign.</p>
<p>The following equivalences to Unicode \p{} constructs and equivalent
backslash character classes (if available), will hold:</p>
<pre>
    <span class="operator">[[</span><span class="operator">:...:</span><span class="operator">]]</span>   <span class="operator">\</span><span class="variable">p</span><span class="operator">{...}</span>         <span class="variable">backslash</span>
</pre>
<pre>
    alpha       IsAlpha
    alnum       IsAlnum
    ascii       IsASCII
    blank
    cntrl       IsCntrl
    digit       IsDigit        \d
    graph       IsGraph
    lower       IsLower
    print       IsPrint
    punct       IsPunct
    space       IsSpace
                IsSpacePerl    \s
    upper       IsUpper
    word        IsWord
    xdigit      IsXDigit</pre>
<p>For example <code>[[:lower:]]</code> and <code>\p{IsLower}</code> are equivalent.</p>
<p>If the <a href="../../lib/pods/perlrun.html#utf8"><code>utf8</code></a> pragma is not used but the <code>locale</code> pragma is, the
classes correlate with the usual <code>isalpha(3)</code> interface (except for
&quot;word&quot; and &quot;blank&quot;).</p>
<p>The other named classes are:</p>
<dl>
<dt><strong><a name="cntrl" class="item">cntrl</a></strong>

<dd>
<p>Any control character.  Usually characters that don't produce output as
such but instead control the terminal somehow: for example newline and
backspace are control characters.  All characters with <a href="../../lib/pods/perlfunc.html#ord"><code>ord()</code></a> less than
32 are usually classified as control characters (assuming ASCII,
the ISO Latin character sets, and Unicode), as is the character with
the <a href="../../lib/pods/perlfunc.html#ord"><code>ord()</code></a> value of 127 (<code>DEL</code>).</p>
</dd>
</li>
<dt><strong><a name="graph" class="item">graph</a></strong>

<dd>
<p>Any alphanumeric or punctuation (special) character.</p>
</dd>
</li>
<dt><strong><a name="print" class="item">print</a></strong>

<dd>
<p>Any alphanumeric or punctuation (special) character or the space character.</p>
</dd>
</li>
<dt><strong><a name="punct" class="item">punct</a></strong>

<dd>
<p>Any punctuation (special) character.</p>
</dd>
</li>
<dt><strong><a name="xdigit" class="item">xdigit</a></strong>

<dd>
<p>Any hexadecimal digit.  Though this may feel silly ([0-9A-Fa-f] would
work just fine) it is included for completeness.</p>
</dd>
</li>
</dl>
<p>You can negate the [::] character classes by prefixing the class name
with a '^'. This is a Perl extension.  For example:</p>
<pre>
    POSIX         traditional  Unicode</pre>
<pre>
    <span class="operator">[[</span><span class="operator">:^</span><span class="variable">digit</span><span class="operator">:</span><span class="operator">]]</span>    <span class="operator">\</span><span class="variable">D</span>         <span class="operator">\</span><span class="variable">P</span><span class="operator">{</span><span class="variable">IsDigit</span><span class="operator">}</span>
    <span class="operator">[[</span><span class="operator">:^</span><span class="variable">space</span><span class="operator">:</span><span class="operator">]]</span>    <span class="operator">\</span><span class="variable">S</span>         <span class="operator">\</span><span class="variable">P</span><span class="operator">{</span><span class="variable">IsSpace</span><span class="operator">}</span>
    <span class="operator">[[</span><span class="operator">:^</span><span class="variable">word</span><span class="operator">:</span><span class="operator">]]</span>     <span class="operator">\</span><span class="variable">W</span>         <span class="operator">\</span><span class="variable">P</span><span class="operator">{</span><span class="variable">IsWord</span><span class="operator">}</span>
</pre>
<p>Perl respects the POSIX standard in that POSIX character classes are
only supported within a character class.  The POSIX character classes
[.cc.] and [=cc=] are recognized but <strong>not</strong> supported and trying to
use them will cause an error.</p>
<p>
</p>
<h3><a name="assertions">Assertions</a></h3>
<p>Perl defines the following zero-width assertions:</p>
<pre>
    \b  Match a word boundary
    \B  Match except at a word boundary
    \A  Match only at beginning of string
    \Z  Match only at end of string, or before newline at the end
    \z  Match only at end of string
    \G  Match only at pos() (e.g. at the end-of-match position
        of prior m//g)</pre>
<p>A word boundary (<a href="../../lib/pods/perlguts.html#b"><code>\b</code></a>) is a spot between two characters
that has a <a href="../../lib/pods/perlrun.html#w"><code>\w</code></a> on one side of it and a <a href="../../lib/pods/perlrun.html#w"><code>\W</code></a> on the other side
of it (in either order), counting the imaginary characters off the
beginning and end of the string as matching a <a href="../../lib/pods/perlrun.html#w"><code>\W</code></a>.  (Within
character classes <a href="../../lib/pods/perlguts.html#b"><code>\b</code></a> represents backspace rather than a word
boundary, just as it normally does in any double-quoted string.)
The <a href="../../lib/pods/perlguts.html#a"><code>\A</code></a> and <code>\Z</code> are just like &quot;^&quot; and &quot;$&quot;, except that they
won't match multiple times when the <a href="#m"><code>/m</code></a> modifier is used, while
&quot;^&quot; and &quot;$&quot; will match at every internal line boundary.  To match
the actual end of the string and not ignore an optional trailing
newline, use <code>\z</code>.</p>
<p>The <code>\G</code> assertion can be used to chain global matches (using
<a href="../../lib/pods/perlfunc.html#m_"><code>m//g</code></a>), as described in <a href="../../lib/pods/perlop.html#regexp_quote_like_operators">Regexp Quote-Like Operators in the perlop manpage</a>.
It is also useful when writing <code>lex</code>-like scanners, when you have
several patterns that you want to match against consequent substrings
of your string, see the previous reference.  The actual location
where <code>\G</code> will match can also be influenced by using <a href="../../lib/pods/perlfunc.html#pos"><code>pos()</code></a> as
an lvalue: see <a href="../../lib/pods/perlfunc.html#pos">pos in the perlfunc manpage</a>. Note that the rule for zero-length
matches is modified somewhat, in that contents to the left of <code>\G</code> is
not counted when determining the length of the match. Thus the following
will not match forever:</p>
<pre>
    <span class="variable">$str</span> <span class="operator">=</span> <span class="string">'ABC'</span><span class="operator">;</span>
    <span class="keyword">pos</span><span class="operator">(</span><span class="variable">$str</span><span class="operator">)</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
    <span class="keyword">while</span> <span class="operator">(</span><span class="regex">/.\G/g</span><span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">print</span> <span class="variable">$&amp;</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<p>It will print 'A' and then terminate, as it considers the match to
be zero-width, and thus will not match at the same position twice in a
row.</p>
<p>It is worth noting that <code>\G</code> improperly used can result in an infinite
loop. Take care when using patterns that include <code>\G</code> in an alternation.</p>
<p>
</p>
<h3><a name="capture_buffers">Capture buffers</a></h3>
<p>The bracketing construct <code>( ... )</code> creates capture buffers. To refer
to the current contents of a buffer later on, within the same pattern,
use \1 for the first, \2 for the second, and so on.
Outside the match use &quot;$&quot; instead of &quot;\&quot;.  (The
\&lt;digit&gt; notation works in certain circumstances outside
the match.  See the warning below about \1 vs $1 for details.)
Referring back to another part of the match is called a
<em>backreference</em>.</p>
<p>There is no limit to the number of captured substrings that you may
use.  However Perl also uses \10, \11, etc. as aliases for \010,
\011, etc.  (Recall that 0 means octal, so \011 is the character at
number 9 in your coded character set; which would be the 10th character,
a horizontal tab under ASCII.)  Perl resolves this
ambiguity by interpreting \10 as a backreference only if at least 10
left parentheses have opened before it.  Likewise \11 is a
backreference only if at least 11 left parentheses have opened
before it.  And so on.  \1 through \9 are always interpreted as
backreferences.</p>
<p>    
In order to provide a safer and easier way to construct patterns using
backreferences, Perl provides the <code>\g{N}</code> notation (starting with perl
5.10.0). The curly brackets are optional, however omitting them is less
safe as the meaning of the pattern can be changed by text (such as digits)
following it. When N is a positive integer the <code>\g{N}</code> notation is
exactly equivalent to using normal backreferences. When N is a negative
integer then it is a relative backreference referring to the previous N'th
capturing group. When the bracket form is used and N is not an integer, it
is treated as a reference to a named buffer.</p>
<p>Thus <code>\g{-1}</code> refers to the last buffer, <code>\g{-2}</code> refers to the
buffer before that. For example:</p>
<pre>
        <span class="regex">/
         (Y)            # buffer 1
         (              # buffer 2
            (X)         # buffer 3
            \g{-1}      # backref to buffer 3
            \g{-3}      # backref to buffer 1
         )
        /x</span>
</pre>
<p>and would match the same as <code>/(Y) ( (X) \3 \1 )/x</code>.</p>
<p>Additionally, as of Perl 5.10.0 you may use named capture buffers and named
backreferences. The notation is <code>(?&lt;name&gt;...)</code> to declare and <code>\k&lt;name&gt;</code>
to reference. You may also use apostrophes instead of angle brackets to delimit the
name; and you may use the bracketed <code>\g{name}</code> backreference syntax.
It's possible to refer to a named capture buffer by absolute and relative number as well.
Outside the pattern, a named capture buffer is available via the <a href="../../lib/pods/perlvar.html#__"><code>%+</code></a> hash.
When different buffers within the same pattern have the same name, <code>$+{name}</code>
and <code>\k&lt;name&gt;</code> refer to the leftmost defined group. (Thus it's possible
to do things with named capture buffers that would otherwise require <code>(??{})</code>
code to accomplish.)
 
   &gt;&gt;</p>
<p>Examples:</p>
<pre>
    <span class="regex">s/^([^ ]*) *([^ ]*)/$2 $1/</span><span class="operator">;</span>     <span class="comment"># swap first two words</span>
</pre>
<pre>
    <span class="regex">/(.)\1/</span>                         <span class="comment"># find first doubled char</span>
         <span class="keyword">and</span> <span class="keyword">print</span> <span class="string">"'</span><span class="variable">$1</span><span class="string">' is the first doubled character\n"</span><span class="operator">;</span>
</pre>
<pre>
    <span class="regex">/(?&lt;char&gt;.)\k&lt;char&gt;/</span>            <span class="comment"># ... a different way</span>
         <span class="keyword">and</span> <span class="keyword">print</span> <span class="string">"'$+{char}' is the first doubled character\n"</span><span class="operator">;</span>
</pre>
<pre>
    <span class="regex">/(?'char'.)\1/</span>                  <span class="comment"># ... mix and match</span>
         <span class="keyword">and</span> <span class="keyword">print</span> <span class="string">"'</span><span class="variable">$1</span><span class="string">' is the first doubled character\n"</span><span class="operator">;</span>
</pre>
<pre>
    <span class="keyword">if</span> <span class="operator">(</span><span class="regex">/Time: (..):(..):(..)/</span><span class="operator">)</span> <span class="operator">{</span>   <span class="comment"># parse out values</span>
        <span class="variable">$hours</span> <span class="operator">=</span> <span class="variable">$1</span><span class="operator">;</span>
        <span class="variable">$minutes</span> <span class="operator">=</span> <span class="variable">$2</span><span class="operator">;</span>
        <span class="variable">$seconds</span> <span class="operator">=</span> <span class="variable">$3</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<p>Several special variables also refer back to portions of the previous
match.  <a href="../../lib/pods/perlvar.html#__"><code>$+</code></a> returns whatever the last bracket match matched.
<a href="../../lib/pods/perlvar.html#__"><code>$&amp;</code></a> returns the entire matched string.  (At one point <a href="../../lib/pods/perlvar.html#_0"><code>$0</code></a> did
also, but now it returns the name of the program.)  <a href="../../lib/pods/perlvar.html#__"><code>$`</code></a> returns
everything before the matched string.  <a href="../../lib/pods/perlvar.html#__"><code>$'</code></a> returns everything
after the matched string. And <a href="../../lib/pods/perlvar.html#__n"><code>$^N</code></a> contains whatever was matched by
the most-recently closed group (submatch). <a href="../../lib/pods/perlvar.html#__n"><code>$^N</code></a> can be used in
extended patterns (see below), for example to assign a submatch to a
variable.</p>
<p>The numbered match variables ($1, $2, $3, etc.) and the related punctuation
set (<a href="../../lib/pods/perlvar.html#__"><code>$+</code></a>, <a href="../../lib/pods/perlvar.html#__"><code>$&amp;</code></a>, <a href="../../lib/pods/perlvar.html#__"><code>$`</code></a>, <a href="../../lib/pods/perlvar.html#__"><code>$'</code></a>, and <a href="../../lib/pods/perlvar.html#__n"><code>$^N</code></a>) are all dynamically scoped
until the end of the enclosing block or until the next successful
match, whichever comes first.  (See <a href="../../lib/pods/perlsyn.html#compound_statements">Compound Statements in the perlsyn manpage</a>.)</p>
<p><strong>NOTE</strong>: Failed matches in Perl do not reset the match variables,
which makes it easier to write code that tests for a series of more
specific cases and remembers the best match.</p>
<p><strong>WARNING</strong>: Once Perl sees that you need one of <a href="../../lib/pods/perlvar.html#__"><code>$&amp;</code></a>, <a href="../../lib/pods/perlvar.html#__"><code>$`</code></a>, or
<a href="../../lib/pods/perlvar.html#__"><code>$'</code></a> anywhere in the program, it has to provide them for every
pattern match.  This may substantially slow your program.  Perl
uses the same mechanism to produce $1, $2, etc, so you also pay a
price for each pattern that contains capturing parentheses.  (To
avoid this cost while retaining the grouping behaviour, use the
extended regular expression <code>(?: ... )</code> instead.)  But if you never
use <a href="../../lib/pods/perlvar.html#__"><code>$&amp;</code></a>, <a href="../../lib/pods/perlvar.html#__"><code>$`</code></a> or <a href="../../lib/pods/perlvar.html#__"><code>$'</code></a>, then patterns <em>without</em> capturing
parentheses will not be penalized.  So avoid <a href="../../lib/pods/perlvar.html#__"><code>$&amp;</code></a>, <a href="../../lib/pods/perlvar.html#__"><code>$'</code></a>, and <a href="../../lib/pods/perlvar.html#__"><code>$`</code></a>
if you can, but if you can't (and some algorithms really appreciate
them), once you've used them once, use them at will, because you've
already paid the price.  As of 5.005, <a href="../../lib/pods/perlvar.html#__"><code>$&amp;</code></a> is not so costly as the
other two.</p>
<p>As a workaround for this problem, Perl 5.10.0 introduces <a href="../../lib/pods/perlvar.html#___prematch_"><code>${^PREMATCH}</code></a>,
<a href="../../lib/pods/perlvar.html#___match_"><code>${^MATCH}</code></a> and <a href="../../lib/pods/perlvar.html#___postmatch_"><code>${^POSTMATCH}</code></a>, which are equivalent to <a href="../../lib/pods/perlvar.html#__"><code>$`</code></a>, <a href="../../lib/pods/perlvar.html#__"><code>$&amp;</code></a>
and <a href="../../lib/pods/perlvar.html#__"><code>$'</code></a>, <strong>except</strong> that they are only guaranteed to be defined after a
successful match that was executed with the <a href="#p"><code>/p</code></a> (preserve) modifier.
The use of these variables incurs no global performance penalty, unlike
their punctuation char equivalents, however at the trade-off that you
have to tell perl when you want to use them.</p>
<p>Backslashed metacharacters in Perl are alphanumeric, such as <a href="../../lib/pods/perlguts.html#b"><code>\b</code></a>,
<a href="../../lib/pods/perlrun.html#w"><code>\w</code></a>, <a href="../../lib/pods/perlrun.html#n"><code>\n</code></a>.  Unlike some other regular expression languages, there
are no backslashed symbols that aren't alphanumeric.  So anything
that looks like \\, \(, \), \&lt;, \&gt;, \{, or \} is always
interpreted as a literal character, not a metacharacter.  This was
once used in a common idiom to disable or quote the special meanings
of regular expression metacharacters in a string that you want to
use for a pattern. Simply quote all non-&quot;word&quot; characters:</p>
<pre>
    <span class="variable">$pattern</span> <span class="operator">=~</span> <span class="regex">s/(\W)/\\$1/g</span><span class="operator">;</span>
</pre>
<p>(If <code>use locale</code> is set, then this depends on the current locale.)
Today it is more common to use the <a href="../../lib/pods/perlfunc.html#quotemeta"><code>quotemeta()</code></a> function or the <code>\Q</code>
metaquoting escape sequence to disable all metacharacters' special
meanings like this:</p>
<pre>
    /$unquoted\Q$quoted\E$unquoted/</pre>
<p>Beware that if you put literal backslashes (those not inside
interpolated variables) between <code>\Q</code> and <a href="../../lib/pods/perlguts.html#e"><code>\E</code></a>, double-quotish
backslash interpolation may lead to confusing results.  If you
<em>need</em> to use literal backslashes within <code>\Q...\E</code>,
consult <a href="../../lib/pods/perlop.html#gory_details_of_parsing_quoted_constructs">Gory details of parsing quoted constructs in the perlop manpage</a>.</p>
<p>
</p>
<h2><a name="extended_patterns">Extended Patterns</a></h2>
<p>Perl also defines a consistent extension syntax for features not
found in standard tools like <strong>awk</strong> and <strong>lex</strong>.  The syntax is a
pair of parentheses with a question mark as the first thing within
the parentheses.  The character after the question mark indicates
the extension.</p>
<p>The stability of these extensions varies widely.  Some have been
part of the core language for many years.  Others are experimental
and may change without warning or be completely removed.  Check
the documentation on an individual feature to verify its current
status.</p>
<p>A question mark was chosen for this and for the minimal-matching
construct because 1) question marks are rare in older regular
expressions, and 2) whenever you see one, you should stop and
&quot;question&quot; exactly what is going on.  That's psychology...</p>
<dl>
<dt><strong><a name="text2" class="item"><a href="#text"><code>(?#text)</code></a></a></strong>

<dd>
<p>A comment.  The text is ignored.  If the <a href="#x"><code>/x</code></a> modifier enables
whitespace formatting, a simple <code>#</code> will suffice.  Note that Perl closes
the comment as soon as it sees a <code>)</code>, so there is no way to put a literal
<code>)</code> in the comment.</p>
</dd>
</li>
<dt><strong><a name="pimsx_imsx" class="item"><code>(?pimsx-imsx)</code></a></strong>

<dd>
<p>One or more embedded pattern-match modifiers, to be turned on (or
turned off, if preceded by <code>-</code>) for the remainder of the pattern or
the remainder of the enclosing pattern group (if any). This is
particularly useful for dynamic patterns, such as those read in from a
configuration file, taken from an argument, or specified in a table
somewhere.  Consider the case where some patterns want to be case
sensitive and some do not:  The case insensitive ones merely need to
include <a href="#i"><code>(?i)</code></a> at the front of the pattern.  For example:</p>
</dd>
<dd>
<pre>
    <span class="variable">$pattern</span> <span class="operator">=</span> <span class="string">"foobar"</span><span class="operator">;</span>
    <span class="keyword">if</span> <span class="operator">(</span> <span class="regex">/</span><span class="variable">$pattern</span><span class="regex">/i</span> <span class="operator">)</span> <span class="operator">{</span> <span class="operator">}</span>
</pre>
</dd>
<dd>
<pre>
    <span class="comment"># more flexible:</span>
</pre>
</dd>
<dd>
<pre>
    <span class="variable">$pattern</span> <span class="operator">=</span> <span class="string">"(?i)foobar"</span><span class="operator">;</span>
    <span class="keyword">if</span> <span class="operator">(</span> <span class="regex">/</span><span class="variable">$pattern</span><span class="regex">/</span> <span class="operator">)</span> <span class="operator">{</span> <span class="operator">}</span>
</pre>
</dd>
<dd>
<p>These modifiers are restored at the end of the enclosing group. For example,</p>
</dd>
<dd>
<pre>
    ( (?i) blah ) \s+ \1</pre>
</dd>
<dd>
<p>will match <code>blah</code> in any case, some spaces, and an exact (<em>including the case</em>!)
repetition of the previous word, assuming the <a href="#x"><code>/x</code></a> modifier, and no <a href="#i"><code>/i</code></a>
modifier outside this group.</p>
</dd>
<dd>
<p>Note that the <a href="#p"><code>p</code></a> modifier is special in that it can only be enabled,
not disabled, and that its presence anywhere in a pattern has a global
effect. Thus <a href="#p"><code>(?-p)</code></a> and <a href="#p"><code>(?-p:...)</code></a> are meaningless and will warn
when executed under <code>use warnings</code>.</p>
</dd>
</li>
<dt><strong><a name="pattern4" class="item"><a href="#pattern"><code>(?:pattern)</code></a></a></strong>

<dt><strong><a name="imsx_imsx_pattern" class="item"><code>(?imsx-imsx:pattern)</code></a></strong>

<dd>
<p>This is for clustering, not capturing; it groups subexpressions like
&quot;()&quot;, but doesn't make backreferences as &quot;()&quot; does.  So</p>
</dd>
<dd>
<pre>
    @fields = split(/\b(?:a|b|c)\b/)</pre>
</dd>
<dd>
<p>is like</p>
</dd>
<dd>
<pre>
    @fields = split(/\b(a|b|c)\b/)</pre>
</dd>
<dd>
<p>but doesn't spit out extra fields.  It's also cheaper not to capture
characters if you don't need to.</p>
</dd>
<dd>
<p>Any letters between <code>?</code> and <code>:</code> act as flags modifiers as with
<code>(?imsx-imsx)</code>.  For example,</p>
</dd>
<dd>
<pre>
    /(?s-i:more.*than).*million/i</pre>
</dd>
<dd>
<p>is equivalent to the more verbose</p>
</dd>
<dd>
<pre>
    /(?:(?s-i)more.*than).*million/i</pre>
</dd>
</li>
<dt><strong><a name="pattern5" class="item"><a href="#pattern"><code>(?|pattern)</code></a></a></strong>

<dd>
<p>This is the &quot;branch reset&quot; pattern, which has the special property
that the capture buffers are numbered from the same starting point
in each alternation branch. It is available starting from perl 5.10.0.</p>
</dd>
<dd>
<p>Capture buffers are numbered from left to right, but inside this
construct the numbering is restarted for each branch.</p>
</dd>
<dd>
<p>The numbering within each branch will be as normal, and any buffers
following this construct will be numbered as though the construct
contained only one branch, that being the one with the most capture
buffers in it.</p>
</dd>
<dd>
<p>This construct will be useful when you want to capture one of a
number of alternative matches.</p>
</dd>
<dd>
<p>Consider the following pattern.  The numbers underneath show in
which buffer the captured content will be stored.</p>
</dd>
<dd>
<pre>
    # before  ---------------branch-reset----------- after        
    / ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
    # 1            2         2  3        2     3     4</pre>
</dd>
<dd>
<p>Note: as of Perl 5.10.0, branch resets interfere with the contents of
the <a href="../../lib/pods/perlvar.html#__"><code>%+</code></a> hash, that holds named captures. Consider using <a href="../../lib/pods/perlvar.html#__"><code>%-</code></a> instead.</p>
</dd>
</li>
<dt><strong><a name="look_around_assertions" class="item">Look-Around Assertions</a></strong>

<dd>
<p>Look-around assertions are zero width patterns which match a specific
pattern without including it in <a href="../../lib/pods/perlvar.html#__"><code>$&amp;</code></a>. Positive assertions match when
their subpattern matches, negative assertions match when their subpattern
fails. Look-behind matches text up to the current match position,
look-ahead matches text following the current match position.</p>
</dd>
<dl>
<dt><strong><a name="pattern6" class="item"><a href="#pattern"><code>(?=pattern)</code></a></a></strong>

<dd>
<p>A zero-width positive look-ahead assertion.  For example, <code>/\w+(?=\t)/</code>
matches a word followed by a tab, without including the tab in <a href="../../lib/pods/perlvar.html#__"><code>$&amp;</code></a>.</p>
</dd>
</li>
<dt><strong><a name="pattern7" class="item"><a href="#pattern"><code>(?!pattern)</code></a></a></strong>

<dd>
<p>A zero-width negative look-ahead assertion.  For example <code>/foo(?!bar)/</code>
matches any occurrence of &quot;foo&quot; that isn't followed by &quot;bar&quot;.  Note
however that look-ahead and look-behind are NOT the same thing.  You cannot
use this for look-behind.</p>
</dd>
<dd>
<p>If you are looking for a &quot;bar&quot; that isn't preceded by a &quot;foo&quot;, <code>/(?!foo)bar/</code>
will not do what you want.  That's because the <code>(?!foo)</code> is just saying that
the next thing cannot be &quot;foo&quot;--and it's not, it's a &quot;bar&quot;, so &quot;foobar&quot; will
match.  You would have to do something like <code>/(?!foo)...bar/</code> for that.   We
say &quot;like&quot; because there's the case of your &quot;bar&quot; not having three characters
before it.  You could cover that this way: <code>/(?:(?!foo)...|^.{0,2})bar/</code>.
Sometimes it's still easier just to say:</p>
</dd>
<dd>
<pre>
    if (/bar/ &amp;&amp; $` !~ /foo$/)</pre>
</dd>
<dd>
<p>For look-behind see below.</p>
</dd>
</li>
<dt><strong><a name="pattern_k" class="item"><a href="#pattern"><code>(?&lt;=pattern)</code></a> <code>\K</code></a></strong>

<dd>
<p>A zero-width positive look-behind assertion.  For example, <code>/(?&lt;=\t)\w+/</code>
matches a word that follows a tab, without including the tab in <a href="../../lib/pods/perlvar.html#__"><code>$&amp;</code></a>.
Works only for fixed-width look-behind.</p>
</dd>
<dd>
<p>There is a special form of this construct, called <code>\K</code>, which causes the
regex engine to &quot;keep&quot; everything it had matched prior to the <code>\K</code> and
not include it in <a href="../../lib/pods/perlvar.html#__"><code>$&amp;</code></a>. This effectively provides variable length
look-behind. The use of <code>\K</code> inside of another look-around assertion
is allowed, but the behaviour is currently not well defined.</p>
</dd>
<dd>
<p>For various reasons <code>\K</code> may be significantly more efficient than the
equivalent <code>(?&lt;=...)</code> construct, and it is especially useful in
situations where you want to efficiently remove something following
something else in a string. For instance</p>
</dd>
<dd>
<pre>
  <span class="regex">s/(foo)bar/$1/g</span><span class="operator">;</span>
</pre>
</dd>
<dd>
<p>can be rewritten as the much more efficient</p>
</dd>
<dd>
<pre>
  <span class="regex">s/foo\Kbar//g</span><span class="operator">;</span>
</pre>
</dd>
</li>
<dt><strong><a name="pattern8" class="item"><a href="#pattern"><code>(?&lt;!pattern)</code></a></a></strong>

<dd>
<p>A zero-width negative look-behind assertion.  For example <code>/(?&lt;!bar)foo/</code>
matches any occurrence of &quot;foo&quot; that does not follow &quot;bar&quot;.  Works
only for fixed-width look-behind.</p>
</dd>
</li>
</dl>
<dt><strong><a name="name_pattern" class="item"><code>(?'NAME'pattern)</code></a></strong>

<dt><strong><a name="name_pattern2" class="item"><a href="#name_pattern"><code>(?&lt;NAME&gt;pattern)</code></a>
) &gt;&gt;</a></strong>

<dd>
<p>A named capture buffer. Identical in every respect to normal capturing
parentheses <code>()</code> but for the additional fact that <a href="../../lib/pods/perlvar.html#__"><code>%+</code></a> or <a href="../../lib/pods/perlvar.html#__"><code>%-</code></a> may be
used after a successful match to refer to a named buffer. See <code>perlvar</code>
for more details on the <a href="../../lib/pods/perlvar.html#__"><code>%+</code></a> and <a href="../../lib/pods/perlvar.html#__"><code>%-</code></a> hashes.</p>
</dd>
<dd>
<p>If multiple distinct capture buffers have the same name then the
$+{NAME} will refer to the leftmost defined buffer in the match.</p>
</dd>
<dd>
<p>The forms <a href="#name_pattern"><code>(?'NAME'pattern)</code></a> and <a href="#name_pattern"><code>(?&lt;NAME&gt;pattern)</code></a> are equivalent.</p>
</dd>
<dd>
<p><strong>NOTE:</strong> While the notation of this construct is the same as the similar
function in .NET regexes, the behavior is not. In Perl the buffers are
numbered sequentially regardless of being named or not. Thus in the
pattern</p>
</dd>
<dd>
<pre>
  /(x)(?&lt;foo&gt;y)(z)/</pre>
</dd>
<dd>
<p>$+{foo} will be the same as $2, and $3 will contain 'z' instead of
the opposite which is what a .NET regex hacker might expect.</p>
</dd>
<dd>
<p>Currently NAME is restricted to simple identifiers only.
In other words, it must match <code>/^[_A-Za-z][_A-Za-z0-9]*\z/</code> or
its Unicode extension (see <a href="../../lib/utf8.html">the utf8 manpage</a>),
though it isn't extended by the locale (see <a href="../../lib/pods/perllocale.html">the perllocale manpage</a>).</p>
</dd>
<dd>
<p><strong>NOTE:</strong> In order to make things easier for programmers with experience
with the Python or PCRE regex engines, the pattern <a href="#p_name_pattern"><code>(?P&lt;NAME&gt;pattern)</code></a>
may be used instead of <a href="#name_pattern"><code>(?&lt;NAME&gt;pattern)</code></a>; however this form does not
support the use of single quotes as a delimiter for the name.</p>
</dd>
</li>
<dt><strong><a name="k_name" class="item"><code>\k&lt;NAME&gt;</code></a></strong>

<dt><strong><a name="k_name2" class="item"><a href="#k_name"><code>\k'NAME'</code></a></a></strong>

<dd>
<p>Named backreference. Similar to numeric backreferences, except that
the group is designated by name and not number. If multiple groups
have the same name then it refers to the leftmost defined group in
the current match.</p>
</dd>
<dd>
<p>It is an error to refer to a name not defined by a <a href="#name"><code>(?&lt;NAME&gt;)</code></a>
earlier in the pattern.</p>
</dd>
<dd>
<p>Both forms are equivalent.</p>
</dd>
<dd>
<p><strong>NOTE:</strong> In order to make things easier for programmers with experience
with the Python or PCRE regex engines, the pattern <a href="#p_name"><code>(?P=NAME)</code></a>
may be used instead of <a href="#k_name"><code>\k&lt;NAME&gt;</code></a>.</p>
</dd>
</li>
<dt><strong><a name="code3" class="item"><a href="#code"><code>(?{ code })</code></a></a></strong>

<dd>
<p><strong>WARNING</strong>: This extended regular expression feature is considered
experimental, and may be changed without notice. Code executed that
has side effects may not perform identically from version to version
due to the effect of future optimisations in the regex engine.</p>
</dd>
<dd>
<p>This zero-width assertion evaluates any embedded Perl code.  It
always succeeds, and its <a href="#code"><code>code</code></a> is not interpolated.  Currently,
the rules to determine where the <a href="#code"><code>code</code></a> ends are somewhat convoluted.</p>
</dd>
<dd>
<p>This feature can be used together with the special variable <a href="../../lib/pods/perlvar.html#__n"><code>$^N</code></a> to
capture the results of submatches in variables without having to keep
track of the number of nested parentheses. For example:</p>
</dd>
<dd>
<pre>
  <span class="variable">$_</span> <span class="operator">=</span> <span class="string">"The brown fox jumps over the lazy dog"</span><span class="operator">;</span>
  <span class="regex">/the (\S+)(?{ </span><span class="variable">$color</span><span class="regex"> = $^N }) (\S+)(?{ </span><span class="variable">$animal</span><span class="regex"> = $^N })/i</span><span class="operator">;</span>
  <span class="keyword">print</span> <span class="string">"color = </span><span class="variable">$color</span><span class="string">, animal = </span><span class="variable">$animal</span><span class="string">\n"</span><span class="operator">;</span>
</pre>
</dd>
<dd>
<p>Inside the <code>(?{...})</code> block, <a href="../../lib/pods/perlvar.html#__"><code>$_</code></a> refers to the string the regular
expression is matching against. You can also use <a href="../../lib/pods/perlfunc.html#pos"><code>pos()</code></a> to know what is
the current position of matching within this string.</p>
</dd>
<dd>
<p>The <a href="#code"><code>code</code></a> is properly scoped in the following sense: If the assertion
is backtracked (compare <a href="#backtracking">Backtracking</a>), all changes introduced after
<a href="../../lib/pods/perlfunc.html#local"><code>local</code></a>ization are undone, so that</p>
</dd>
<dd>
<pre>
  <span class="variable">$_</span> <span class="operator">=</span> <span class="string">'a'</span> <span class="operator">x</span> <span class="number">8</span><span class="operator">;</span>
  <span class="regex">m&lt;
     (?{ </span><span class="variable">$cnt</span><span class="regex"> = 0 })                    # Initialize </span><span class="variable">$cnt</span><span class="regex">.
     (
       a
       (?{
           local </span><span class="variable">$cnt</span><span class="regex"> = </span><span class="variable">$cnt</span><span class="regex"> + 1;       # Update </span><span class="variable">$cnt</span><span class="regex">, backtracking-safe.
       })
     )*
     aaaa
     (?{ </span><span class="variable">$res</span><span class="regex"> = </span><span class="variable">$cnt</span><span class="regex"> })                 # On success copy to non-localized
                                        # location.
   &gt;x</span><span class="operator">;</span>
</pre>
</dd>
<dd>
<p>will set <code>$res = 4</code>.  Note that after the match, <code>$cnt</code> returns to the globally
introduced value, because the scopes that restrict <a href="../../lib/pods/perlfunc.html#local"><code>local</code></a> operators
are unwound.</p>
</dd>
<dd>
<p>This assertion may be used as a <a href="#condition_yes_pattern_no_pattern"><code>(?(condition)yes-pattern|no-pattern)</code></a>
switch.  If <em>not</em> used in this way, the result of evaluation of
<a href="#code"><code>code</code></a> is put into the special variable <a href="../../lib/pods/perlvar.html#__r"><code>$^R</code></a>.  This happens
immediately, so <a href="../../lib/pods/perlvar.html#__r"><code>$^R</code></a> can be used from other <a href="#code"><code>(?{ code })</code></a> assertions
inside the same regular expression.</p>
</dd>
<dd>
<p>The assignment to <a href="../../lib/pods/perlvar.html#__r"><code>$^R</code></a> above is properly localized, so the old
value of <a href="../../lib/pods/perlvar.html#__r"><code>$^R</code></a> is restored if the assertion is backtracked; compare
<a href="#backtracking">Backtracking</a>.</p>
</dd>
<dd>
<p>Due to an unfortunate implementation issue, the Perl code contained in these
blocks is treated as a compile time closure that can have seemingly bizarre
consequences when used with lexically scoped variables inside of subroutines
or loops.  There are various workarounds for this, including simply using
global variables instead.  If you are using this construct and strange results
occur then check for the use of lexically scoped variables.</p>
</dd>
<dd>
<p>For reasons of security, this construct is forbidden if the regular
expression involves run-time interpolation of variables, unless the
perilous <code>use re 'eval'</code> pragma has been used (see <a href="../../lib/re.html">the re manpage</a>), or the
variables contain results of <a href="../../lib/pods/perlfunc.html#qr_"><code>qr//</code></a> operator (see
<a href="../../lib/pods/perlop.html#qr_string_imosx">qr/STRING/imosx in the perlop manpage</a>).</p>
</dd>
<dd>
<p>This restriction is due to the wide-spread and remarkably convenient
custom of using run-time determined strings as patterns.  For example:</p>
</dd>
<dd>
<pre>
    <span class="variable">$re</span> <span class="operator">=</span> <span class="operator">&lt;&gt;;</span>
    <span class="keyword">chomp</span> <span class="variable">$re</span><span class="operator">;</span>
    <span class="variable">$string</span> <span class="operator">=~</span> <span class="regex">/</span><span class="variable">$re</span><span class="regex">/</span><span class="operator">;</span>
</pre>
</dd>
<dd>
<p>Before Perl knew how to execute interpolated code within a pattern,
this operation was completely safe from a security point of view,
although it could raise an exception from an illegal pattern.  If
you turn on the <code>use re 'eval'</code>, though, it is no longer secure,
so you should only do so if you are also using taint checking.
Better yet, use the carefully constrained evaluation within a Safe
compartment.  See <a href="../../lib/pods/perlsec.html">the perlsec manpage</a> for details about both these mechanisms.</p>
</dd>
<dd>
<p>Because Perl's regex engine is currently not re-entrant, interpolated
code may not invoke the regex engine either directly with <a href="../../lib/pods/perlfunc.html#m_"><code>m//</code></a> or <a href="../../lib/pods/perlfunc.html#s_"><code>s///</code></a>),
or indirectly with functions such as <a href="../../lib/pods/perlfunc.html#split"><code>split</code></a>.</p>
</dd>
</li>
<dt><strong><a name="code4" class="item"><a href="#code"><code>(??{ code })</code></a></a></strong>

<dd>
<p><strong>WARNING</strong>: This extended regular expression feature is considered
experimental, and may be changed without notice. Code executed that
has side effects may not perform identically from version to version
due to the effect of future optimisations in the regex engine.</p>
</dd>
<dd>
<p>This is a &quot;postponed&quot; regular subexpression.  The <a href="#code"><code>code</code></a> is evaluated
at run time, at the moment this subexpression may match.  The result
of evaluation is considered as a regular expression and matched as
if it were inserted instead of this construct.  Note that this means
that the contents of capture buffers defined inside an eval'ed pattern
are not available outside of the pattern, and vice versa, there is no
way for the inner pattern to refer to a capture buffer defined outside.
Thus,</p>
</dd>
<dd>
<pre>
    <span class="operator">(</span><span class="string">'a'</span> <span class="operator">x</span> <span class="number">100</span><span class="operator">)=~</span><span class="regex">/(??{'(.)' x 100})/</span>
</pre>
</dd>
<dd>
<p><strong>will</strong> match, it will <strong>not</strong> set $1.</p>
</dd>
<dd>
<p>The <a href="#code"><code>code</code></a> is not interpolated.  As before, the rules to determine
where the <a href="#code"><code>code</code></a> ends are currently somewhat convoluted.</p>
</dd>
<dd>
<p>The following pattern matches a parenthesized group:</p>
</dd>
<dd>
<pre>
  <span class="variable">$re</span> <span class="operator">=</span> <span class="string">qr{
             \(
             (?:
                (?&gt; [^()]+ )    # Non-parens without backtracking
              |
                (??{ </span><span class="variable">$re</span><span class="string"> })     # Group with matching parens
             )*
             \)
          }x</span><span class="operator">;</span>
</pre>
</dd>
<dd>
<p>See also <code>(?PARNO)</code> for a different, more efficient way to accomplish
the same task.</p>
</dd>
<dd>
<p>Because perl's regex engine is not currently re-entrant, delayed
code may not invoke the regex engine either directly with <a href="../../lib/pods/perlfunc.html#m_"><code>m//</code></a> or <a href="../../lib/pods/perlfunc.html#s_"><code>s///</code></a>),
or indirectly with functions such as <a href="../../lib/pods/perlfunc.html#split"><code>split</code></a>.</p>
</dd>
<dd>
<p>Recursing deeper than 50 times without consuming any input string will
result in a fatal error.  The maximum depth is compiled into perl, so
changing it requires a custom build.</p>
</dd>
</li>
<dt><strong><a name="parno_parno_parno_r_0" class="item"><code>(?PARNO)</code> <code>(?-PARNO)</code> <code>(?+PARNO)</code> <a href="#r"><code>(?R)</code></a> <code>(?0)</code></a></strong>

<dd>
<p>Similar to <a href="#code"><code>(??{ code })</code></a> except it does not involve compiling any code,
instead it treats the contents of a capture buffer as an independent
pattern that must match at the current position.  Capture buffers
contained by the pattern will have the value as determined by the
outermost recursion.</p>
</dd>
<dd>
<p>PARNO is a sequence of digits (not starting with 0) whose value reflects
the paren-number of the capture buffer to recurse to. <a href="#r"><code>(?R)</code></a> recurses to
the beginning of the whole pattern. <code>(?0)</code> is an alternate syntax for
<a href="#r"><code>(?R)</code></a>. If PARNO is preceded by a plus or minus sign then it is assumed
to be relative, with negative numbers indicating preceding capture buffers
and positive ones following. Thus <a href="#1"><code>(?-1)</code></a> refers to the most recently
declared buffer, and <a href="#1"><code>(?+1)</code></a> indicates the next buffer to be declared.
Note that the counting for relative recursion differs from that of
relative backreferences, in that with recursion unclosed buffers <strong>are</strong>
included.</p>
</dd>
<dd>
<p>The following pattern matches a function <code>foo()</code> which may contain
balanced parentheses as the argument.</p>
</dd>
<dd>
<pre>
  <span class="variable">$re</span> <span class="operator">=</span> <span class="string">qr{ (                    # paren group 1 (full function)
              foo
              (                  # paren group 2 (parens)
                \(
                  (              # paren group 3 (contents of parens)
                  (?:
                   (?&gt; [^()]+ )  # Non-parens without backtracking
                  |
                   (?2)          # Recurse to start of paren group 2
                  )*
                  )
                \)
              )
            )
          }x</span><span class="operator">;</span>
</pre>
</dd>
<dd>
<p>If the pattern was used as follows</p>
</dd>
<dd>
<pre>
    <span class="string">'foo(bar(baz)+baz(bop))'</span><span class="operator">=~</span><span class="regex">/</span><span class="variable">$re</span><span class="regex">/</span>
        <span class="keyword">and</span> <span class="keyword">print</span> <span class="string">"\$1 = </span><span class="variable">$1</span><span class="string">\n"</span><span class="operator">,</span>
                  <span class="string">"\$2 = </span><span class="variable">$2</span><span class="string">\n"</span><span class="operator">,</span>
                  <span class="string">"\$3 = </span><span class="variable">$3</span><span class="string">\n"</span><span class="operator">;</span>
</pre>
</dd>
<dd>
<p>the output produced should be the following:</p>
</dd>
<dd>
<pre>
    $1 = foo(bar(baz)+baz(bop))
    $2 = (bar(baz)+baz(bop))
    $3 = bar(baz)+baz(bop)</pre>
</dd>
<dd>
<p>If there is no corresponding capture buffer defined, then it is a
fatal error.  Recursing deeper than 50 times without consuming any input
string will also result in a fatal error.  The maximum depth is compiled
into perl, so changing it requires a custom build.</p>
</dd>
<dd>
<p>The following shows how using negative indexing can make it
easier to embed recursive patterns inside of a <a href="../../lib/pods/perlfunc.html#qr_"><code>qr//</code></a> construct
for later use:</p>
</dd>
<dd>
<pre>
    <span class="keyword">my</span> <span class="variable">$parens</span> <span class="operator">=</span> <span class="string">qr/(\((?:[^()]++|(?-1))*+\))/</span><span class="operator">;</span>
    <span class="keyword">if</span> <span class="operator">(</span><span class="regex">/foo </span><span class="variable">$parens</span><span class="regex"> \s+ + \s+ bar </span><span class="variable">$parens</span><span class="regex">/x</span><span class="operator">)</span> <span class="operator">{</span>
       <span class="comment"># do something here...</span>
    <span class="operator">}</span>
</pre>
</dd>
<dd>
<p><strong>Note</strong> that this pattern does not behave the same way as the equivalent
PCRE or Python construct of the same form. In Perl you can backtrack into
a recursed group, in PCRE and Python the recursed into group is treated
as atomic. Also, modifiers are resolved at compile time, so constructs
like (?i:(?1)) or (?:(?i)(?1)) do not affect how the sub-pattern will
be processed.</p>
</dd>
</li>
<dt><strong><a name="name10" class="item"><a href="#name"><code>(?&amp;NAME)</code></a></a></strong>

<dd>
<p>Recurse to a named subpattern. Identical to <code>(?PARNO)</code> except that the
parenthesis to recurse to is determined by name. If multiple parentheses have
the same name, then it recurses to the leftmost.</p>
</dd>
<dd>
<p>It is an error to refer to a name that is not declared somewhere in the
pattern.</p>
</dd>
<dd>
<p><strong>NOTE:</strong> In order to make things easier for programmers with experience
with the Python or PCRE regex engines the pattern <a href="#p_name"><code>(?P&gt;NAME)</code></a>
may be used instead of <a href="#name"><code>(?&amp;NAME)</code></a>.</p>
</dd>
</li>
<dt><strong><a name="condition_yes_pattern_no_pattern" class="item"><code>(?(condition)yes-pattern|no-pattern)</code></a></strong>

<dt><strong><a name="condition_yes_pattern" class="item"><code>(?(condition)yes-pattern)</code></a></strong>

<dd>
<p>Conditional expression.  <code>(condition)</code> should be either an integer in
parentheses (which is valid if the corresponding pair of parentheses
matched), a look-ahead/look-behind/evaluate zero-width assertion, a
name in angle brackets or single quotes (which is valid if a buffer
with the given name matched), or the special symbol (R) (true when
evaluated inside of recursion or eval). Additionally the R may be
followed by a number, (which will be true when evaluated when recursing
inside of the appropriate group), or by <a href="#name"><code>&amp;NAME</code></a>, in which case it will
be true only when evaluated during recursion in the named group.</p>
</dd>
<dd>
<p>Here's a summary of the possible predicates:</p>
</dd>
<dl>
<dt><strong><a name="1_2" class="item">(1) (2) ...</a></strong>

<dd>
<p>Checks if the numbered capturing buffer has matched something.</p>
</dd>
</li>
<dt><strong><a name="name_name" class="item">(&lt;NAME&gt;) ('NAME')</a></strong>

<dd>
<p>Checks if a buffer with the given name has matched something.</p>
</dd>
</li>
<dt><strong><a name="code2" class="item">(?{ CODE })</a></strong>

<dd>
<p>Treats the code block as the condition.</p>
</dd>
</li>
<dt><strong><a name="r3" class="item">(R)</a></strong>

<dd>
<p>Checks if the expression has been evaluated inside of recursion.</p>
</dd>
</li>
<dt><strong><a name="r1_r2" class="item">(R1) (R2) ...</a></strong>

<dd>
<p>Checks if the expression has been evaluated while executing directly
inside of the n-th capture group. This check is the regex equivalent of</p>
</dd>
<dd>
<pre>
  <span class="keyword">if</span> <span class="operator">((</span><span class="keyword">caller</span><span class="operator">(</span><span class="number">0</span><span class="operator">))</span><span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="keyword">eq</span> <span class="string">'subname'</span><span class="operator">)</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
</pre>
</dd>
<dd>
<p>In other words, it does not check the full recursion stack.</p>
</dd>
</li>
<dt><strong><a name="r_name" class="item">(R&amp;NAME)</a></strong>

<dd>
<p>Similar to <code>(R1)</code>, this predicate checks to see if we're executing
directly inside of the leftmost group with a given name (this is the same
logic used by <a href="#name"><code>(?&amp;NAME)</code></a> to disambiguate). It does not check the full
stack, but only the name of the innermost active recursion.</p>
</dd>
</li>
<dt><strong><a name="define2" class="item">(DEFINE)</a></strong>

<dd>
<p>In this case, the yes-pattern is never directly executed, and no
no-pattern is allowed. Similar in spirit to <code>(?{0})</code> but more efficient.
See below for details.</p>
</dd>
</li>
</dl>
<p>For example:</p>
<pre>
    <span class="regex">m{ ( \( )?
       [^()]+
       (?(1) \) )
     }x</span>
</pre>
<p>matches a chunk of non-parentheses, possibly included in parentheses
themselves.</p>
<p>A special form is the <a href="#define"><code>(DEFINE)</code></a> predicate, which never executes directly
its yes-pattern, and does not allow a no-pattern. This allows to define
subpatterns which will be executed only by using the recursion mechanism.
This way, you can define a set of regular expression rules that can be
bundled into any pattern you choose.</p>
<p>It is recommended that for this usage you put the DEFINE block at the
end of the pattern, and that you name any subpatterns defined within it.</p>
<p>Also, it's worth noting that patterns defined this way probably will
not be as efficient, as the optimiser is not very clever about
handling them.</p>
<p>An example of how this might be used is as follows:</p>
<pre>
  /(?&lt;NAME&gt;(?&amp;NAME_PAT))(?&lt;ADDR&gt;(?&amp;ADDRESS_PAT))
   (?(DEFINE)
     (?&lt;NAME_PAT&gt;....)
     (?&lt;ADRESS_PAT&gt;....)
   )/x</pre>
<p>Note that capture buffers matched inside of recursion are not accessible
after the recursion returns, so the extra layer of capturing buffers is
necessary. Thus <code>$+{NAME_PAT}</code> would not be defined even though
<code>$+{NAME}</code> would be.</p>
<dt><strong><a name="pattern9" class="item"><a href="#pattern"><code>(?&gt;pattern)</code></a></a></strong>

<dd>
<p>An &quot;independent&quot; subexpression, one which matches the substring
that a <em>standalone</em> <a href="#pattern"><code>pattern</code></a> would match if anchored at the given
position, and it matches <em>nothing other than this substring</em>.  This
construct is useful for optimizations of what would otherwise be
&quot;eternal&quot; matches, because it will not backtrack (see <a href="#backtracking">Backtracking</a>).
It may also be useful in places where the &quot;grab all you can, and do not
give anything back&quot; semantic is desirable.</p>
</dd>
<dd>
<p>For example: <code>^(?&gt;a*)ab</code> will never match, since <a href="../../lib/pods/perlrun.html#a"><code>(?&gt;a*)</code></a>
(anchored at the beginning of string, as above) will match <em>all</em>
characters <a href="../../lib/pods/perlrun.html#a"><code>a</code></a> at the beginning of string, leaving no <a href="../../lib/pods/perlrun.html#a"><code>a</code></a> for
<code>ab</code> to match.  In contrast, <code>a*ab</code> will match the same as <code>a+b</code>,
since the match of the subgroup <a href="../../lib/pods/perlrun.html#a"><code>a*</code></a> is influenced by the following
group <code>ab</code> (see <a href="#backtracking">Backtracking</a>).  In particular, <a href="../../lib/pods/perlrun.html#a"><code>a*</code></a> inside
<code>a*ab</code> will match fewer characters than a standalone <a href="../../lib/pods/perlrun.html#a"><code>a*</code></a>, since
this makes the tail match.</p>
</dd>
<dd>
<p>An effect similar to <a href="#pattern"><code>(?&gt;pattern)</code></a> may be achieved by writing
<code>(?=(pattern))\1</code>.  This matches the same substring as a standalone
<a href="../../lib/pods/perlrun.html#a"><code>a+</code></a>, and the following <a href="#1"><code>\1</code></a> eats the matched string; it therefore
makes a zero-length assertion into an analogue of <code>(?&gt;...)</code>.
(The difference between these two constructs is that the second one
uses a capturing group, thus shifting ordinals of backreferences
in the rest of a regular expression.)</p>
</dd>
<dd>
<p>Consider this pattern:</p>
</dd>
<dd>
<pre>
    <span class="regex">m{ \(
          (
            [^()]+              # x+
          |
            \( [^()]* \)
          )+
       \)
     }x</span>
</pre>
</dd>
<dd>
<p>That will efficiently match a nonempty group with matching parentheses
two levels deep or less.  However, if there is no such group, it
will take virtually forever on a long string.  That's because there
are so many different ways to split a long string into several
substrings.  This is what <code>(.+)+</code> is doing, and <code>(.+)+</code> is similar
to a subpattern of the above pattern.  Consider how the pattern
above detects no-match on <code>((()aaaaaaaaaaaaaaaaaa</code> in several
seconds, but that each extra letter doubles this time.  This
exponential performance will make it appear that your program has
hung.  However, a tiny change to this pattern</p>
</dd>
<dd>
<pre>
    <span class="regex">m{ \(
          (
            (?&gt; [^()]+ )        # change x+ above to (?&gt; x+ )
          |
            \( [^()]* \)
          )+
       \)
     }x</span>
</pre>
</dd>
<dd>
<p>which uses <code>(?&gt;...)</code> matches exactly when the one above does (verifying
this yourself would be a productive exercise), but finishes in a fourth
the time when used on a similar string with 1000000 <a href="../../lib/pods/perlrun.html#a"><code>a</code></a>s.  Be aware,
however, that this pattern currently triggers a warning message under
the <code>use warnings</code> pragma or <strong>-w</strong> switch saying it
<code>&quot;matches null string many times in regex&quot;</code>.</p>
</dd>
<dd>
<p>On simple groups, such as the pattern <code>(?&gt; [^()]+ )</code>, a comparable
effect may be achieved by negative look-ahead, as in <code>[^()]+ (?! [^()] )</code>.
This was only 4 times slower on a string with 1000000 <a href="../../lib/pods/perlrun.html#a"><code>a</code></a>s.</p>
</dd>
<dd>
<p>The &quot;grab all you can, and do not give anything back&quot; semantic is desirable
in many situations where on the first sight a simple <code>()*</code> looks like
the correct solution.  Suppose we parse text with comments being delimited
by <code>#</code> followed by some optional (horizontal) whitespace.  Contrary to
its appearance, <a href="../../lib/pods/perlrun.html#t"><code>#[ \t]*</code></a> <em>is not</em> the correct subexpression to match
the comment delimiter, because it may &quot;give up&quot; some whitespace if
the remainder of the pattern can be made to match that way.  The correct
answer is either one of these:</p>
</dd>
<dd>
<pre>
    (?&gt;#[ \t]*)
    #[ \t]*(?![ \t])</pre>
</dd>
<dd>
<p>For example, to grab non-empty comments into $1, one should use either
one of these:</p>
</dd>
<dd>
<pre>
    <span class="regex">/ (?&gt; \# [ \t]* ) (        .+ ) /x</span><span class="operator">;</span>
    <span class="regex">/     \# [ \t]*   ( [^ \t] .* ) /x</span><span class="operator">;</span>
</pre>
</dd>
<dd>
<p>Which one you pick depends on which of these expressions better reflects
the above specification of comments.</p>
</dd>
<dd>
<p>In some literature this construct is called &quot;atomic matching&quot; or
&quot;possessive matching&quot;.</p>
</dd>
<dd>
<p>Possessive quantifiers are equivalent to putting the item they are applied
to inside of one of these constructs. The following equivalences apply:</p>
</dd>
<dd>
<pre>
    Quantifier Form     Bracketing Form
    ---------------     ---------------
    PAT*+               (?&gt;PAT*)
    PAT++               (?&gt;PAT+)
    PAT?+               (?&gt;PAT?)
    PAT{min,max}+       (?&gt;PAT{min,max})</pre>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="special_backtracking_control_verbs">Special Backtracking Control Verbs</a></h2>
<p><strong>WARNING:</strong> These patterns are experimental and subject to change or
removal in a future version of Perl. Their usage in production code should
be noted to avoid problems during upgrades.</p>
<p>These special patterns are generally of the form <code>(*VERB:ARG)</code>. Unless
otherwise stated the ARG argument is optional; in some cases, it is
forbidden.</p>
<p>Any pattern containing a special backtracking verb that allows an argument
has the special behaviour that when executed it sets the current packages'
<code>$REGERROR</code> and <code>$REGMARK</code> variables. When doing so the following
rules apply:</p>
<p>On failure, the <code>$REGERROR</code> variable will be set to the ARG value of the
verb pattern, if the verb was involved in the failure of the match. If the
ARG part of the pattern was omitted, then <code>$REGERROR</code> will be set to the
name of the last <code>(*MARK:NAME)</code> pattern executed, or to TRUE if there was
none. Also, the <code>$REGMARK</code> variable will be set to FALSE.</p>
<p>On a successful match, the <code>$REGERROR</code> variable will be set to FALSE, and
the <code>$REGMARK</code> variable will be set to the name of the last
<code>(*MARK:NAME)</code> pattern executed.  See the explanation for the
<code>(*MARK:NAME)</code> verb below for more details.</p>
<p><strong>NOTE:</strong> <code>$REGERROR</code> and <code>$REGMARK</code> are not magic variables like <code>$1</code>
and most other regex related variables. They are not local to a scope, nor
readonly, but instead are volatile package variables similar to <code>$AUTOLOAD</code>.
Use <a href="../../lib/pods/perlfunc.html#local"><code>local</code></a> to localize changes to them to a specific scope if necessary.</p>
<p>If a pattern does not contain a special backtracking verb that allows an
argument, then <code>$REGERROR</code> and <code>$REGMARK</code> are not touched at all.</p>
<dl>
<dt><strong><a name="verbs_that_take_an_argument" class="item">Verbs that take an argument</a></strong>

<dl>
<dt><strong><a name="prune_prune_name" class="item"><code>(*PRUNE)</code> <code>(*PRUNE:NAME)</code></a></strong>

<dd>
<p>This zero-width pattern prunes the backtracking tree at the current point
when backtracked into on failure. Consider the pattern <a href="../../lib/pods/perlguts.html#a"><code>A (*PRUNE) B</code></a>,
where A and B are complex patterns. Until the <code>(*PRUNE)</code> verb is reached,
A may backtrack as necessary to match. Once it is reached, matching
continues in B, which may also backtrack as necessary; however, should B
not match, then no further backtracking will take place, and the pattern
will fail outright at the current starting position.</p>
</dd>
<dd>
<p>The following example counts all the possible matching strings in a
pattern (without actually matching any of them).</p>
</dd>
<dd>
<pre>
    <span class="string">'aaab'</span> <span class="operator">=~</span> <span class="regex">/a+b?(?{print "$&amp;\n"; </span><span class="variable">$count</span><span class="regex">++})(*FAIL)/</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"Count=</span><span class="variable">$count</span><span class="string">\n"</span><span class="operator">;</span>
</pre>
</dd>
<dd>
<p>which produces:</p>
</dd>
<dd>
<pre>
    aaab
    aaa
    aa
    a
    aab
    aa
    a
    ab
    a
    Count=9</pre>
</dd>
<dd>
<p>If we add a <code>(*PRUNE)</code> before the count like the following</p>
</dd>
<dd>
<pre>
    <span class="string">'aaab'</span> <span class="operator">=~</span> <span class="regex">/a+b?(*PRUNE)(?{print "$&amp;\n"; </span><span class="variable">$count</span><span class="regex">++})(*FAIL)/</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"Count=</span><span class="variable">$count</span><span class="string">\n"</span><span class="operator">;</span>
</pre>
</dd>
<dd>
<p>we prevent backtracking and find the count of the longest matching
at each matching starting point like so:</p>
</dd>
<dd>
<pre>
    aaab
    aab
    ab
    Count=3</pre>
</dd>
<dd>
<p>Any number of <code>(*PRUNE)</code> assertions may be used in a pattern.</p>
</dd>
<dd>
<p>See also <a href="#pattern"><code>(?&gt;pattern)</code></a> and possessive quantifiers for other ways to
control backtracking. In some cases, the use of <code>(*PRUNE)</code> can be
replaced with a <a href="#pattern"><code>(?&gt;pattern)</code></a> with no functional difference; however,
<code>(*PRUNE)</code> can be used to handle cases that cannot be expressed using a
<a href="#pattern"><code>(?&gt;pattern)</code></a> alone.</p>
</dd>
</li>
<dt><strong><a name="skip_skip_name" class="item"><code>(*SKIP)</code> <code>(*SKIP:NAME)</code></a></strong>

<dd>
<p>This zero-width pattern is similar to <code>(*PRUNE)</code>, except that on
failure it also signifies that whatever text that was matched leading up
to the <code>(*SKIP)</code> pattern being executed cannot be part of <em>any</em> match
of this pattern. This effectively means that the regex engine &quot;skips&quot; forward
to this position on failure and tries to match again, (assuming that
there is sufficient room to match).</p>
</dd>
<dd>
<p>The name of the <code>(*SKIP:NAME)</code> pattern has special significance. If a
<code>(*MARK:NAME)</code> was encountered while matching, then it is that position
which is used as the &quot;skip point&quot;. If no <code>(*MARK)</code> of that name was
encountered, then the <code>(*SKIP)</code> operator has no effect. When used
without a name the &quot;skip point&quot; is where the match point was when
executing the (*SKIP) pattern.</p>
</dd>
<dd>
<p>Compare the following to the examples in <code>(*PRUNE)</code>, note the string
is twice as long:</p>
</dd>
<dd>
<pre>
    <span class="string">'aaabaaab'</span> <span class="operator">=~</span> <span class="regex">/a+b?(*SKIP)(?{print "$&amp;\n"; </span><span class="variable">$count</span><span class="regex">++})(*FAIL)/</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"Count=</span><span class="variable">$count</span><span class="string">\n"</span><span class="operator">;</span>
</pre>
</dd>
<dd>
<p>outputs</p>
</dd>
<dd>
<pre>
    aaab
    aaab
    Count=2</pre>
</dd>
<dd>
<p>Once the 'aaab' at the start of the string has matched, and the <code>(*SKIP)</code>
executed, the next starting point will be where the cursor was when the
<code>(*SKIP)</code> was executed.</p>
</dd>
</li>
<dt><strong><a name="mark_name_name_mark_name_name" class="item"><code>(*MARK:NAME)</code> <a href="#name"><code>(*:NAME)</code></a>
 <code>(*MARK:NAME)</code> <a href="#name"><code>(*:NAME)</code></a></a></strong>

<dd>
<p>This zero-width pattern can be used to mark the point reached in a string
when a certain part of the pattern has been successfully matched. This
mark may be given a name. A later <code>(*SKIP)</code> pattern will then skip
forward to that point if backtracked into on failure. Any number of
<code>(*MARK)</code> patterns are allowed, and the NAME portion is optional and may
be duplicated.</p>
</dd>
<dd>
<p>In addition to interacting with the <code>(*SKIP)</code> pattern, <code>(*MARK:NAME)</code>
can be used to &quot;label&quot; a pattern branch, so that after matching, the
program can determine which branches of the pattern were involved in the
match.</p>
</dd>
<dd>
<p>When a match is successful, the <code>$REGMARK</code> variable will be set to the
name of the most recently executed <code>(*MARK:NAME)</code> that was involved
in the match.</p>
</dd>
<dd>
<p>This can be used to determine which branch of a pattern was matched
without using a separate capture buffer for each branch, which in turn
can result in a performance improvement, as perl cannot optimize
<code>/(?:(x)|(y)|(z))/</code> as efficiently as something like
<a href="#x"><code>/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/</code></a>.</p>
</dd>
<dd>
<p>When a match has failed, and unless another verb has been involved in
failing the match and has provided its own name to use, the <code>$REGERROR</code>
variable will be set to the name of the most recently executed
<code>(*MARK:NAME)</code>.</p>
</dd>
<dd>
<p>See <code>(*SKIP)</code> for more details.</p>
</dd>
<dd>
<p>As a shortcut <code>(*MARK:NAME)</code> can be written <a href="#name"><code>(*:NAME)</code></a>.</p>
</dd>
</li>
<dt><strong><a name="then_then_name" class="item"><code>(*THEN)</code> <code>(*THEN:NAME)</code></a></strong>

<dd>
<p>This is similar to the &quot;cut group&quot; operator <code>::</code> from Perl 6. Like
<code>(*PRUNE)</code>, this verb always matches, and when backtracked into on
failure, it causes the regex engine to try the next alternation in the
innermost enclosing group (capturing or otherwise).</p>
</dd>
<dd>
<p>Its name comes from the observation that this operation combined with the
alternation operator (<code>|</code>) can be used to create what is essentially a
pattern-based if/then/else block:</p>
</dd>
<dd>
<pre>
  ( COND (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ )</pre>
</dd>
<dd>
<p>Note that if this operator is used and NOT inside of an alternation then
it acts exactly like the <code>(*PRUNE)</code> operator.</p>
</dd>
<dd>
<pre>
  / A (*PRUNE) B /</pre>
</dd>
<dd>
<p>is the same as</p>
</dd>
<dd>
<pre>
  / A (*THEN) B /</pre>
</dd>
<dd>
<p>but</p>
</dd>
<dd>
<pre>
  / ( A (*THEN) B | C (*THEN) D ) /</pre>
</dd>
<dd>
<p>is not the same as</p>
</dd>
<dd>
<pre>
  / ( A (*PRUNE) B | C (*PRUNE) D ) /</pre>
</dd>
<dd>
<p>as after matching the A but failing on the B the <code>(*THEN)</code> verb will
backtrack and try C; but the <code>(*PRUNE)</code> verb will simply fail.</p>
</dd>
</li>
<dt><strong><a name="commit" class="item"><code>(*COMMIT)</code></a></strong>

<dd>
<p>This is the Perl 6 &quot;commit pattern&quot; <code>&lt;commit&gt;</code> or <code>:::</code>. It's a
zero-width pattern similar to <code>(*SKIP)</code>, except that when backtracked
into on failure it causes the match to fail outright. No further attempts
to find a valid match by advancing the start pointer will occur again.
For example,</p>
</dd>
<dd>
<pre>
    <span class="string">'aaabaaab'</span> <span class="operator">=~</span> <span class="regex">/a+b?(*COMMIT)(?{print "$&amp;\n"; </span><span class="variable">$count</span><span class="regex">++})(*FAIL)/</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"Count=</span><span class="variable">$count</span><span class="string">\n"</span><span class="operator">;</span>
</pre>
</dd>
<dd>
<p>outputs</p>
</dd>
<dd>
<pre>
    aaab
    Count=1</pre>
</dd>
<dd>
<p>In other words, once the <a href="#commit"><code>(*COMMIT)</code></a> has been entered, and if the pattern
does not match, the regex engine will not try any further matching on the
rest of the string.</p>
</dd>
</li>
</dl>
<dt><strong><a name="verbs_without_an_argument" class="item">Verbs without an argument</a></strong>

<dl>
<dt><strong><a name="fail_f" class="item"><code>(*FAIL)</code> <code>(*F)</code></a></strong>

<dd>
<p>This pattern matches nothing and always fails. It can be used to force the
engine to backtrack. It is equivalent to <code>(?!)</code>, but easier to read. In
fact, <code>(?!)</code> gets optimised into <code>(*FAIL)</code> internally.</p>
</dd>
<dd>
<p>It is probably useful only when combined with <code>(?{})</code> or <code>(??{})</code>.</p>
</dd>
</li>
<dt><strong><a name="accept" class="item"><code>(*ACCEPT)</code></a></strong>

<dd>
<p><strong>WARNING:</strong> This feature is highly experimental. It is not recommended
for production code.</p>
</dd>
<dd>
<p>This pattern matches nothing and causes the end of successful matching at
the point at which the <a href="#accept"><code>(*ACCEPT)</code></a> pattern was encountered, regardless of
whether there is actually more to match in the string. When inside of a
nested pattern, such as recursion, or in a subpattern dynamically generated
via <code>(??{})</code>, only the innermost pattern is ended immediately.</p>
</dd>
<dd>
<p>If the <a href="#accept"><code>(*ACCEPT)</code></a> is inside of capturing buffers then the buffers are
marked as ended at the point at which the <a href="#accept"><code>(*ACCEPT)</code></a> was encountered.
For instance:</p>
</dd>
<dd>
<pre>
  <span class="string">'AB'</span> <span class="operator">=~</span> <span class="regex">/(A (A|B(*ACCEPT)|C) D)(E)/x</span><span class="operator">;</span>
</pre>
</dd>
<dd>
<p>will match, and <code>$1</code> will be <code>AB</code> and <code>$2</code> will be <code>B</code>, <code>$3</code> will not
be set. If another branch in the inner parentheses were matched, such as in the
string 'ACDE', then the <code>D</code> and <a href="../../lib/pods/perlguts.html#e"><code>E</code></a> would have to be matched as well.</p>
</dd>
</li>
</dl>
</dl>
<p>
</p>
<h2><a name="backtracking">Backtracking</a></h2>
<p>NOTE: This section presents an abstract approximation of regular
expression behavior.  For a more rigorous (and complicated) view of
the rules involved in selecting a match among possible alternatives,
see <a href="#combining_re_pieces">Combining RE Pieces</a>.</p>
<p>A fundamental feature of regular expression matching involves the
notion called <em>backtracking</em>, which is currently used (when needed)
by all regular non-possessive expression quantifiers, namely <code>*</code>, <code>*?</code>, <code>+</code>,
<code>+?</code>, <code>{n,m}</code>, and <code>{n,m}?</code>.  Backtracking is often optimized
internally, but the general principle outlined here is valid.</p>
<p>For a regular expression to match, the <em>entire</em> regular expression must
match, not just part of it.  So if the beginning of a pattern containing a
quantifier succeeds in a way that causes later parts in the pattern to
fail, the matching engine backs up and recalculates the beginning
part--that's why it's called backtracking.</p>
<p>Here is an example of backtracking:  Let's say you want to find the
word following &quot;foo&quot; in the string &quot;Food is on the foo table.&quot;:</p>
<pre>
    <span class="variable">$_</span> <span class="operator">=</span> <span class="string">"Food is on the foo table."</span><span class="operator">;</span>
    <span class="keyword">if</span> <span class="operator">(</span> <span class="regex">/\b(foo)\s+(\w+)/i</span> <span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">print</span> <span class="string">"</span><span class="variable">$2</span><span class="string"> follows </span><span class="variable">$1</span><span class="string">.\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<p>When the match runs, the first part of the regular expression (<a href="../../lib/pods/perlguts.html#b"><code>\b(foo)</code></a>)
finds a possible match right at the beginning of the string, and loads up
$1 with &quot;Foo&quot;.  However, as soon as the matching engine sees that there's
no whitespace following the &quot;Foo&quot; that it had saved in $1, it realizes its
mistake and starts over again one character after where it had the
tentative match.  This time it goes all the way until the next occurrence
of &quot;foo&quot;. The complete regular expression matches this time, and you get
the expected output of &quot;table follows foo.&quot;</p>
<p>Sometimes minimal matching can help a lot.  Imagine you'd like to match
everything between &quot;foo&quot; and &quot;bar&quot;.  Initially, you write something
like this:</p>
<pre>
    <span class="variable">$_</span> <span class="operator">=</span>  <span class="string">"The food is under the bar in the barn."</span><span class="operator">;</span>
    <span class="keyword">if</span> <span class="operator">(</span> <span class="regex">/foo(.*)bar/</span> <span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">print</span> <span class="string">"got &lt;</span><span class="variable">$1</span><span class="string">&gt;\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<p>Which perhaps unexpectedly yields:</p>
<pre>
  got &lt;d is under the bar in the &gt;</pre>
<p>That's because <code>.*</code> was greedy, so you get everything between the
<em>first</em> &quot;foo&quot; and the <em>last</em> &quot;bar&quot;.  Here it's more effective
to use minimal matching to make sure you get the text between a &quot;foo&quot;
and the first &quot;bar&quot; thereafter.</p>
<pre>
    <span class="keyword">if</span> <span class="operator">(</span> <span class="regex">/foo(.*?)bar/</span> <span class="operator">)</span> <span class="operator">{</span> <span class="keyword">print</span> <span class="string">"got &lt;</span><span class="variable">$1</span><span class="string">&gt;\n"</span> <span class="operator">}</span>
      <span class="variable">got</span> <span class="operator">&lt;</span><span class="variable">d</span> <span class="variable">is</span> <span class="variable">under</span> <span class="variable">the</span> <span class="operator">&gt;</span>
</pre>
<p>Here's another example. Let's say you'd like to match a number at the end
of a string, and you also want to keep the preceding part of the match.
So you write this:</p>
<pre>
    <span class="variable">$_</span> <span class="operator">=</span> <span class="string">"I have 2 numbers: 53147"</span><span class="operator">;</span>
    <span class="keyword">if</span> <span class="operator">(</span> <span class="regex">/(.*)(\d*)/</span> <span class="operator">)</span> <span class="operator">{</span>                                <span class="comment"># Wrong!</span>
        <span class="keyword">print</span> <span class="string">"Beginning is &lt;</span><span class="variable">$1</span><span class="string">&gt;, number is &lt;</span><span class="variable">$2</span><span class="string">&gt;.\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<p>That won't work at all, because <code>.*</code> was greedy and gobbled up the
whole string. As <a href="../../lib/pods/perlrun.html#d"><code>\d*</code></a> can match on an empty string the complete
regular expression matched successfully.</p>
<pre>
    Beginning is &lt;I have 2 numbers: 53147&gt;, number is &lt;&gt;.</pre>
<p>Here are some variants, most of which don't work:</p>
<pre>
    <span class="variable">$_</span> <span class="operator">=</span> <span class="string">"I have 2 numbers: 53147"</span><span class="operator">;</span>
    <span class="variable">@pats</span> <span class="operator">=</span> <span class="string">qw{
        (.*)(\d*)
        (.*)(\d+)
        (.*?)(\d*)
        (.*?)(\d+)
        (.*)(\d+)$
        (.*?)(\d+)$
        (.*)\b(\d+)$
        (.*\D)(\d+)$
    }</span><span class="operator">;</span>
</pre>
<pre>
    <span class="keyword">for</span> <span class="variable">$pat</span> <span class="operator">(</span><span class="variable">@pats</span><span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">printf</span> <span class="string">"%-12s "</span><span class="operator">,</span> <span class="variable">$pat</span><span class="operator">;</span>
        <span class="keyword">if</span> <span class="operator">(</span> <span class="regex">/</span><span class="variable">$pat</span><span class="regex">/</span> <span class="operator">)</span> <span class="operator">{</span>
            <span class="keyword">print</span> <span class="string">"&lt;</span><span class="variable">$1</span><span class="string">&gt; &lt;</span><span class="variable">$2</span><span class="string">&gt;\n"</span><span class="operator">;</span>
        <span class="operator">}</span> <span class="keyword">else</span> <span class="operator">{</span>
            <span class="keyword">print</span> <span class="string">"FAIL\n"</span><span class="operator">;</span>
        <span class="operator">}</span>
    <span class="operator">}</span>
</pre>
<p>That will print out:</p>
<pre>
    (.*)(\d*)    &lt;I have 2 numbers: 53147&gt; &lt;&gt;
    (.*)(\d+)    &lt;I have 2 numbers: 5314&gt; &lt;7&gt;
    (.*?)(\d*)   &lt;&gt; &lt;&gt;
    (.*?)(\d+)   &lt;I have &gt; &lt;2&gt;
    (.*)(\d+)$   &lt;I have 2 numbers: 5314&gt; &lt;7&gt;
    (.*?)(\d+)$  &lt;I have 2 numbers: &gt; &lt;53147&gt;
    (.*)\b(\d+)$ &lt;I have 2 numbers: &gt; &lt;53147&gt;
    (.*\D)(\d+)$ &lt;I have 2 numbers: &gt; &lt;53147&gt;</pre>
<p>As you see, this can be a bit tricky.  It's important to realize that a
regular expression is merely a set of assertions that gives a definition
of success.  There may be 0, 1, or several different ways that the
definition might succeed against a particular string.  And if there are
multiple ways it might succeed, you need to understand backtracking to
know which variety of success you will achieve.</p>
<p>When using look-ahead assertions and negations, this can all get even
trickier.  Imagine you'd like to find a sequence of non-digits not
followed by &quot;123&quot;.  You might try to write that as</p>
<pre>
    <span class="variable">$_</span> <span class="operator">=</span> <span class="string">"ABC123"</span><span class="operator">;</span>
    <span class="keyword">if</span> <span class="operator">(</span> <span class="regex">/^\D*(?!123)/</span> <span class="operator">)</span> <span class="operator">{</span>              <span class="comment"># Wrong!</span>
        <span class="keyword">print</span> <span class="string">"Yup, no 123 in </span><span class="variable">$_</span><span class="string">\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<p>But that isn't going to match; at least, not the way you're hoping.  It
claims that there is no 123 in the string.  Here's a clearer picture of
why that pattern matches, contrary to popular expectations:</p>
<pre>
    <span class="variable">$x</span> <span class="operator">=</span> <span class="string">'ABC123'</span><span class="operator">;</span>
    <span class="variable">$y</span> <span class="operator">=</span> <span class="string">'ABC445'</span><span class="operator">;</span>
</pre>
<pre>
    <span class="keyword">print</span> <span class="string">"1: got </span><span class="variable">$1</span><span class="string">\n"</span> <span class="keyword">if</span> <span class="variable">$x</span> <span class="operator">=~</span> <span class="regex">/^(ABC)(?!123)/</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"2: got </span><span class="variable">$1</span><span class="string">\n"</span> <span class="keyword">if</span> <span class="variable">$y</span> <span class="operator">=~</span> <span class="regex">/^(ABC)(?!123)/</span><span class="operator">;</span>
</pre>
<pre>
    <span class="keyword">print</span> <span class="string">"3: got </span><span class="variable">$1</span><span class="string">\n"</span> <span class="keyword">if</span> <span class="variable">$x</span> <span class="operator">=~</span> <span class="regex">/^(\D*)(?!123)/</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"4: got </span><span class="variable">$1</span><span class="string">\n"</span> <span class="keyword">if</span> <span class="variable">$y</span> <span class="operator">=~</span> <span class="regex">/^(\D*)(?!123)/</span><span class="operator">;</span>
</pre>
<p>This prints</p>
<pre>
    2: got ABC
    3: got AB
    4: got ABC</pre>
<p>You might have expected test 3 to fail because it seems to a more
general purpose version of test 1.  The important difference between
them is that test 3 contains a quantifier (<code>\D*</code>) and so can use
backtracking, whereas test 1 will not.  What's happening is
that you've asked &quot;Is it true that at the start of $x, following 0 or more
non-digits, you have something that's not 123?&quot;  If the pattern matcher had
let <code>\D*</code> expand to &quot;ABC&quot;, this would have caused the whole pattern to
fail.</p>
<p>The search engine will initially match <code>\D*</code> with &quot;ABC&quot;.  Then it will
try to match <code>(?!123</code> with &quot;123&quot;, which fails.  But because
a quantifier (<code>\D*</code>) has been used in the regular expression, the
search engine can backtrack and retry the match differently
in the hope of matching the complete regular expression.</p>
<p>The pattern really, <em>really</em> wants to succeed, so it uses the
standard pattern back-off-and-retry and lets <code>\D*</code> expand to just &quot;AB&quot; this
time.  Now there's indeed something following &quot;AB&quot; that is not
&quot;123&quot;.  It's &quot;C123&quot;, which suffices.</p>
<p>We can deal with this by using both an assertion and a negation.
We'll say that the first part in $1 must be followed both by a digit
and by something that's not &quot;123&quot;.  Remember that the look-aheads
are zero-width expressions--they only look, but don't consume any
of the string in their match.  So rewriting this way produces what
you'd expect; that is, case 5 will fail, but case 6 succeeds:</p>
<pre>
    <span class="keyword">print</span> <span class="string">"5: got </span><span class="variable">$1</span><span class="string">\n"</span> <span class="keyword">if</span> <span class="variable">$x</span> <span class="operator">=~</span> <span class="regex">/^(\D*)(?=\d)(?!123)/</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"6: got </span><span class="variable">$1</span><span class="string">\n"</span> <span class="keyword">if</span> <span class="variable">$y</span> <span class="operator">=~</span> <span class="regex">/^(\D*)(?=\d)(?!123)/</span><span class="operator">;</span>
</pre>
<pre>
    6: got ABC</pre>
<p>In other words, the two zero-width assertions next to each other work as though
they're ANDed together, just as you'd use any built-in assertions:  <code>/^$/</code>
matches only if you're at the beginning of the line AND the end of the
line simultaneously.  The deeper underlying truth is that juxtaposition in
regular expressions always means AND, except when you write an explicit OR
using the vertical bar.  <code>/ab/</code> means match &quot;a&quot; AND (then) match &quot;b&quot;,
although the attempted matches are made at different positions because &quot;a&quot;
is not a zero-width assertion, but a one-width assertion.</p>
<p><strong>WARNING</strong>: Particularly complicated regular expressions can take
exponential time to solve because of the immense number of possible
ways they can use backtracking to try for a match.  For example, without
internal optimizations done by the regular expression engine, this will
take a painfully long time to run:</p>
<pre>
    <span class="string">'aaaaaaaaaaaa'</span> <span class="operator">=~</span> <span class="regex">/((a{0,5}){0,5})*[c]/</span>
</pre>
<p>And if you used <code>*</code>'s in the internal groups instead of limiting them
to 0 through 5 matches, then it would take forever--or until you ran
out of stack space.  Moreover, these internal optimizations are not
always applicable.  For example, if you put <code>{0,5}</code> instead of <code>*</code>
on the external group, no current optimization is applicable, and the
match takes a long time to finish.</p>
<p>A powerful tool for optimizing such beasts is what is known as an
&quot;independent group&quot;,
which does not backtrack (see <a href="#pattern"><code>&lt; (?&gt;pattern) &gt;</code></a>).  Note also that
zero-length look-ahead/look-behind assertions will not backtrack to make
the tail match, since they are in &quot;logical&quot; context: only
whether they match is considered relevant.  For an example
where side-effects of look-ahead <em>might</em> have influenced the
following match, see <a href="#pattern"><code>&lt; (?&gt;pattern) &gt;</code></a>.</p>
<p>
</p>
<h2><a name="version_8_regular_expressions">Version 8 Regular Expressions</a></h2>
<p>In case you're not familiar with the &quot;regular&quot; Version 8 regex
routines, here are the pattern-matching rules not described above.</p>
<p>Any single character matches itself, unless it is a <em>metacharacter</em>
with a special meaning described here or above.  You can cause
characters that normally function as metacharacters to be interpreted
literally by prefixing them with a &quot;\&quot; (e.g., &quot;\.&quot; matches a &quot;.&quot;, not any
character; &quot;\\&quot; matches a &quot;\&quot;). This escape mechanism is also required
for the character used as the pattern delimiter.</p>
<p>A series of characters matches that series of characters in the target
string, so the pattern  <code>blurfl</code> would match &quot;blurfl&quot; in the target
string.</p>
<p>You can specify a character class, by enclosing a list of characters
in <code>[]</code>, which will match any character from the list.  If the
first character after the &quot;[&quot; is &quot;^&quot;, the class matches any character not
in the list.  Within a list, the &quot;-&quot; character specifies a
range, so that <code>a-z</code> represents all characters between &quot;a&quot; and &quot;z&quot;,
inclusive.  If you want either &quot;-&quot; or &quot;]&quot; itself to be a member of a
class, put it at the start of the list (possibly after a &quot;^&quot;), or
escape it with a backslash.  &quot;-&quot; is also taken literally when it is
at the end of the list, just before the closing &quot;]&quot;.  (The
following all specify the same class of three characters: <code>[-az]</code>,
<code>[az-]</code>, and <code>[a\-z]</code>.  All are different from <code>[a-z]</code>, which
specifies a class containing twenty-six characters, even on EBCDIC-based
character sets.)  Also, if you try to use the character
classes <a href="../../lib/pods/perlrun.html#w"><code>\w</code></a>, <a href="../../lib/pods/perlrun.html#w"><code>\W</code></a>, <a href="#s"><code>\s</code></a>, <a href="#s"><code>\S</code></a>, <a href="../../lib/pods/perlrun.html#d"><code>\d</code></a>, or <code>\D</code> as endpoints of
a range, the &quot;-&quot; is understood literally.</p>
<p>Note also that the whole range idea is rather unportable between
character sets--and even within character sets they may cause results
you probably didn't expect.  A sound principle is to use only ranges
that begin from and end at either alphabetics of equal case ([a-e],
[A-E]), or digits ([0-9]).  Anything else is unsafe.  If in doubt,
spell out the character sets in full.</p>
<p>Characters may be specified using a metacharacter syntax much like that
used in C: &quot;\n&quot; matches a newline, &quot;\t&quot; a tab, &quot;\r&quot; a carriage return,
&quot;\f&quot; a form feed, etc.  More generally, \<em>nnn</em>, where <em>nnn</em> is a string
of octal digits, matches the character whose coded character set value
is <em>nnn</em>.  Similarly, \x<em>nn</em>, where <em>nn</em> are hexadecimal digits,
matches the character whose numeric value is <em>nn</em>. The expression \c<em>x</em>
matches the character control-<em>x</em>.  Finally, the &quot;.&quot; metacharacter
matches any character except &quot;\n&quot; (unless you use <a href="#s"><code>/s</code></a>).</p>
<p>You can specify a series of alternatives for a pattern using &quot;|&quot; to
separate them, so that <code>fee|fie|foe</code> will match any of &quot;fee&quot;, &quot;fie&quot;,
or &quot;foe&quot; in the target string (as would <a href="../../lib/pods/perlrun.html#f"><code>f(e|i|o)e</code></a>).  The
first alternative includes everything from the last pattern delimiter
(&quot;(&quot;, &quot;[&quot;, or the beginning of the pattern) up to the first &quot;|&quot;, and
the last alternative contains everything from the last &quot;|&quot; to the next
pattern delimiter.  That's why it's common practice to include
alternatives in parentheses: to minimize confusion about where they
start and end.</p>
<p>Alternatives are tried from left to right, so the first
alternative found for which the entire expression matches, is the one that
is chosen. This means that alternatives are not necessarily greedy. For
example: when matching <code>foo|foot</code> against &quot;barefoot&quot;, only the &quot;foo&quot;
part will match, as that is the first alternative tried, and it successfully
matches the target string. (This might not seem important, but it is
important when you are capturing matched text using parentheses.)</p>
<p>Also remember that &quot;|&quot; is interpreted as a literal within square brackets,
so if you write <code>[fee|fie|foe]</code> you're really only matching <code>[feio|]</code>.</p>
<p>Within a pattern, you may designate subpatterns for later reference
by enclosing them in parentheses, and you may refer back to the
<em>n</em>th subpattern later in the pattern using the metacharacter
\<em>n</em>.  Subpatterns are numbered based on the left to right order
of their opening parenthesis.  A backreference matches whatever
actually matched the subpattern in the string being examined, not
the rules for that subpattern.  Therefore, <code>(0|0x)\d*\s\1\d*</code> will
match &quot;0x1234 0x4321&quot;, but not &quot;0x1234 01234&quot;, because subpattern
1 matched &quot;0x&quot;, even though the rule <code>0|0x</code> could potentially match
the leading 0 in the second number.</p>
<p>
</p>
<h2><a name="warning_on__1_instead_of__1">Warning on \1 Instead of $1</a></h2>
<p>Some people get too used to writing things like:</p>
<pre>
    <span class="variable">$pattern</span> <span class="operator">=~</span> <span class="regex">s/(\W)/\\\1/g</span><span class="operator">;</span>
</pre>
<p>This is grandfathered for the RHS of a substitute to avoid shocking the
<strong>sed</strong> addicts, but it's a dirty habit to get into.  That's because in
PerlThink, the righthand side of an <a href="../../lib/pods/perlfunc.html#s_"><code>s///</code></a> is a double-quoted string.  <a href="#1"><code>\1</code></a> in
the usual double-quoted string means a control-A.  The customary Unix
meaning of <a href="#1"><code>\1</code></a> is kludged in for <a href="../../lib/pods/perlfunc.html#s_"><code>s///</code></a>.  However, if you get into the habit
of doing that, you get yourself into trouble if you then add an <code>/e</code>
modifier.</p>
<pre>
    <span class="regex">s/(\d+)/ \1 + 1 /eg</span><span class="operator">;</span>        <span class="comment"># causes warning under -w</span>
</pre>
<p>Or if you try to do</p>
<pre>
    <span class="regex">s/(\d+)/\1000/</span><span class="operator">;</span>
</pre>
<p>You can't disambiguate that by saying <code>\{1}000</code>, whereas you can fix it with
<code>${1}000</code>.  The operation of interpolation should not be confused
with the operation of matching a backreference.  Certainly they mean two
different things on the <em>left</em> side of the <a href="../../lib/pods/perlfunc.html#s_"><code>s///</code></a>.</p>
<p>
</p>
<h2><a name="repeated_patterns_matching_a_zero_length_substring">Repeated Patterns Matching a Zero-length Substring</a></h2>
<p><strong>WARNING</strong>: Difficult material (and prose) ahead.  This section needs a rewrite.</p>
<p>Regular expressions provide a terse and powerful programming language.  As
with most other power tools, power comes together with the ability
to wreak havoc.</p>
<p>A common abuse of this power stems from the ability to make infinite
loops using regular expressions, with something as innocuous as:</p>
<pre>
    <span class="string">'foo'</span> <span class="operator">=~</span> <span class="regex">m{ ( o? )* }x</span><span class="operator">;</span>
</pre>
<p>The <a href="../../lib/pods/perlguts.html#o"><code>o?</code></a> matches at the beginning of <code>'foo'</code>, and since the position
in the string is not moved by the match, <a href="../../lib/pods/perlguts.html#o"><code>o?</code></a> would match again and again
because of the <code>*</code> quantifier.  Another common way to create a similar cycle
is with the looping modifier <code>//g</code>:</p>
<pre>
    <span class="variable">@matches</span> <span class="operator">=</span> <span class="operator">(</span> <span class="string">'foo'</span> <span class="operator">=~</span> <span class="regex">m{ o? }xg</span> <span class="operator">);</span>
</pre>
<p>or</p>
<pre>
    <span class="keyword">print</span> <span class="string">"match: &lt;$&amp;&gt;\n"</span> <span class="keyword">while</span> <span class="string">'foo'</span> <span class="operator">=~</span> <span class="regex">m{ o? }xg</span><span class="operator">;</span>
</pre>
<p>or the loop implied by <a href="../../lib/pods/perlfunc.html#split"><code>split()</code></a>.</p>
<p>However, long experience has shown that many programming tasks may
be significantly simplified by using repeated subexpressions that
may match zero-length substrings.  Here's a simple example being:</p>
<pre>
    <span class="variable">@chars</span> <span class="operator">=</span> <span class="keyword">split</span> <span class="regex">//</span><span class="operator">,</span> <span class="variable">$string</span><span class="operator">;</span>           <span class="comment"># // is not magic in split</span>
    <span class="operator">(</span><span class="variable">$whitewashed</span> <span class="operator">=</span> <span class="variable">$string</span><span class="operator">)</span> <span class="operator">=~</span> <span class="regex">s/()/ /g</span><span class="operator">;</span> <span class="comment"># parens avoid magic s// /</span>
</pre>
<p>Thus Perl allows such constructs, by <em>forcefully breaking
the infinite loop</em>.  The rules for this are different for lower-level
loops given by the greedy quantifiers <code>*+{}</code>, and for higher-level
ones like the <code>/g</code> modifier or <a href="../../lib/pods/perlfunc.html#split"><code>split()</code></a> operator.</p>
<p>The lower-level loops are <em>interrupted</em> (that is, the loop is
broken) when Perl detects that a repeated expression matched a
zero-length substring.   Thus</p>
<pre>
   <span class="regex">m{ (?: NON_ZERO_LENGTH | ZERO_LENGTH )* }x</span><span class="operator">;</span>
</pre>
<p>is made equivalent to</p>
<pre>
   <span class="regex">m{   (?: NON_ZERO_LENGTH )*
      |
        (?: ZERO_LENGTH )?
    }x</span><span class="operator">;</span>
</pre>
<p>The higher level-loops preserve an additional state between iterations:
whether the last match was zero-length.  To break the loop, the following
match after a zero-length match is prohibited to have a length of zero.
This prohibition interacts with backtracking (see <a href="#backtracking">Backtracking</a>),
and so the <em>second best</em> match is chosen if the <em>best</em> match is of
zero length.</p>
<p>For example:</p>
<pre>
    <span class="variable">$_</span> <span class="operator">=</span> <span class="string">'bar'</span><span class="operator">;</span>
    <span class="regex">s/\w??/&lt;$&amp;&gt;/g</span><span class="operator">;</span>
</pre>
<p>results in <code>&lt;&gt;&lt;b&gt;&lt;&gt;&lt;a&gt;&lt;&gt;&lt;r&gt;&lt;&gt;</code>.  At each position of the string the best
match given by non-greedy <code>??</code> is the zero-length match, and the <em>second
best</em> match is what is matched by <a href="../../lib/pods/perlrun.html#w"><code>\w</code></a>.  Thus zero-length matches
alternate with one-character-long matches.</p>
<p>Similarly, for repeated <a href="../../lib/pods/perlfunc.html#m_"><code>m/()/g</code></a> the second-best match is the match at the
position one notch further in the string.</p>
<p>The additional state of being <em>matched with zero-length</em> is associated with
the matched string, and is reset by each assignment to <a href="../../lib/pods/perlfunc.html#pos"><code>pos()</code></a>.
Zero-length matches at the end of the previous match are ignored
during <a href="../../lib/pods/perlfunc.html#split"><code>split</code></a>.</p>
<p>
</p>
<h2><a name="combining_re_pieces">Combining RE Pieces</a></h2>
<p>Each of the elementary pieces of regular expressions which were described
before (such as <code>ab</code> or <code>\Z</code>) could match at most one substring
at the given position of the input string.  However, in a typical regular
expression these elementary pieces are combined into more complicated
patterns using combining operators <a href="#st"><code>ST</code></a>, <a href="#s_t"><code>S|T</code></a>, <a href="#s"><code>S*</code></a> etc
(in these examples <a href="#s"><code>S</code></a> and <a href="../../lib/pods/perlrun.html#t"><code>T</code></a> are regular subexpressions).</p>
<p>Such combinations can include alternatives, leading to a problem of choice:
if we match a regular expression <code>a|ab</code> against <code>&quot;abc&quot;</code>, will it match
substring <a href="../../lib/pods/perlrun.html#a"><code>&quot;a&quot;</code></a> or <code>&quot;ab&quot;</code>?  One way to describe which substring is
actually matched is the concept of backtracking (see <a href="#backtracking">Backtracking</a>).
However, this description is too low-level and makes you think
in terms of a particular implementation.</p>
<p>Another description starts with notions of &quot;better&quot;/&quot;worse&quot;.  All the
substrings which may be matched by the given regular expression can be
sorted from the &quot;best&quot; match to the &quot;worst&quot; match, and it is the &quot;best&quot;
match which is chosen.  This substitutes the question of &quot;what is chosen?&quot;
by the question of &quot;which matches are better, and which are worse?&quot;.</p>
<p>Again, for elementary pieces there is no such question, since at most
one match at a given position is possible.  This section describes the
notion of better/worse for combining operators.  In the description
below <a href="#s"><code>S</code></a> and <a href="../../lib/pods/perlrun.html#t"><code>T</code></a> are regular subexpressions.</p>
<dl>
<dt><strong><a name="st2" class="item"><a href="#st"><code>ST</code></a></a></strong>

<dd>
<p>Consider two possible matches, <code>AB</code> and <code>A'B'</code>, <a href="../../lib/pods/perlguts.html#a"><code>A</code></a> and <a href="../../lib/pods/perlguts.html#a"><code>A'</code></a> are
substrings which can be matched by <a href="#s"><code>S</code></a>, <code>B</code> and <code>B'</code> are substrings
which can be matched by <a href="../../lib/pods/perlrun.html#t"><code>T</code></a>.</p>
</dd>
<dd>
<p>If <a href="../../lib/pods/perlguts.html#a"><code>A</code></a> is better match for <a href="#s"><code>S</code></a> than <a href="../../lib/pods/perlguts.html#a"><code>A'</code></a>, <code>AB</code> is a better
match than <code>A'B'</code>.</p>
</dd>
<dd>
<p>If <a href="../../lib/pods/perlguts.html#a"><code>A</code></a> and <a href="../../lib/pods/perlguts.html#a"><code>A'</code></a> coincide: <code>AB</code> is a better match than <code>AB'</code> if
<code>B</code> is better match for <a href="../../lib/pods/perlrun.html#t"><code>T</code></a> than <code>B'</code>.</p>
</dd>
</li>
<dt><strong><a name="s_t" class="item"><code>S|T</code></a></strong>

<dd>
<p>When <a href="#s"><code>S</code></a> can match, it is a better match than when only <a href="../../lib/pods/perlrun.html#t"><code>T</code></a> can match.</p>
</dd>
<dd>
<p>Ordering of two matches for <a href="#s"><code>S</code></a> is the same as for <a href="#s"><code>S</code></a>.  Similar for
two matches for <a href="../../lib/pods/perlrun.html#t"><code>T</code></a>.</p>
</dd>
</li>
<dt><strong><a name="s" class="item"><code>S{REPEAT_COUNT}</code></a></strong>

<dd>
<p>Matches as <code>SSS...S</code> (repeated as many times as necessary).</p>
</dd>
</li>
<dt><strong><code>S{min,max}</code></strong>

<dd>
<p>Matches as <a href="#s"><code>S{max}|S{max-1}|...|S{min+1}|S{min}</code></a>.</p>
</dd>
</li>
<dt><strong><a name="s_min_max" class="item"><code>S{min,max}?</code></a></strong>

<dd>
<p>Matches as <a href="#s"><code>S{min}|S{min+1}|...|S{max-1}|S{max}</code></a>.</p>
</dd>
</li>
<dt><strong><a name="s_s_s" class="item"><a href="#s"><code>S?</code></a>, <a href="#s"><code>S*</code></a>, <a href="#s"><code>S+</code></a></a></strong>

<dd>
<p>Same as <a href="#s"><code>S{0,1}</code></a>, <a href="#s"><code>S{0,BIG_NUMBER}</code></a>, <a href="#s"><code>S{1,BIG_NUMBER}</code></a> respectively.</p>
</dd>
</li>
<dt><strong><a name="s_s_s2" class="item"><a href="#s"><code>S??</code></a>, <a href="#s"><code>S*?</code></a>, <a href="#s"><code>S+?</code></a></a></strong>

<dd>
<p>Same as <code>S{0,1}?</code>, <code>S{0,BIG_NUMBER}?</code>, <code>S{1,BIG_NUMBER}?</code> respectively.</p>
</dd>
</li>
<dt><strong><a name="s4" class="item"><a href="#s"><code>(?&gt;S)</code></a></a></strong>

<dd>
<p>Matches the best match for <a href="#s"><code>S</code></a> and only that.</p>
</dd>
</li>
<dt><strong><a name="s_s" class="item"><a href="#s"><code>(?=S)</code></a>, <a href="#s"><code>(?&lt;=S)</code></a></a></strong>

<dd>
<p>Only the best match for <a href="#s"><code>S</code></a> is considered.  (This is important only if
<a href="#s"><code>S</code></a> has capturing parentheses, and backreferences are used somewhere
else in the whole regular expression.)</p>
</dd>
</li>
<dt><strong><a name="s_s2" class="item"><a href="#s"><code>(?!S)</code></a>, <a href="#s"><code>(?&lt;!S)</code></a></a></strong>

<dd>
<p>For this grouping operator there is no need to describe the ordering, since
only whether or not <a href="#s"><code>S</code></a> can match is important.</p>
</dd>
</li>
<dt><strong><a name="expr_parno" class="item"><code>(??{ EXPR })</code>, <code>(?PARNO)</code></a></strong>

<dd>
<p>The ordering is the same as for the regular expression which is
the result of EXPR, or the pattern contained by capture buffer PARNO.</p>
</dd>
</li>
<dt><strong><a name="condition_yes_pattern_no_pattern2" class="item"><a href="#condition_yes_pattern_no_pattern"><code>(?(condition)yes-pattern|no-pattern)</code></a></a></strong>

<dd>
<p>Recall that which of <code>yes-pattern</code> or <code>no-pattern</code> actually matches is
already determined.  The ordering of the matches is the same as for the
chosen subexpression.</p>
</dd>
</li>
</dl>
<p>The above recipes describe the ordering of matches <em>at a given position</em>.
One more rule is needed to understand how a match is determined for the
whole regular expression: a match at an earlier position is always better
than a match at a later position.</p>
<p>
</p>
<h2><a name="creating_custom_re_engines">Creating Custom RE Engines</a></h2>
<p>Overloaded constants (see <a href="../../lib/overload.html">the overload manpage</a>) provide a simple way to extend
the functionality of the RE engine.</p>
<p>Suppose that we want to enable a new RE escape-sequence <code>\Y|</code> which
matches at a boundary between whitespace characters and non-whitespace
characters.  Note that <code>(?=\S)(?&lt;!\S)|(?!\S)(?&lt;=\S)</code> matches exactly
at these positions, so we want to have each <code>\Y|</code> in the place of the
more complicated version.  We can create a module <code>customre</code> to do
this:</p>
<pre>
    <span class="keyword">package</span> <span class="variable">customre</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">overload</span><span class="operator">;</span>
</pre>
<pre>
    <span class="keyword">sub</span><span class="variable"> import </span><span class="operator">{</span>
      <span class="keyword">shift</span><span class="operator">;</span>
      <span class="keyword">die</span> <span class="string">"No argument to customre::import allowed"</span> <span class="keyword">if</span> <span class="variable">@_</span><span class="operator">;</span>
      <span class="variable">overload::constant</span> <span class="string">'qr'</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">convert</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<pre>
    <span class="keyword">sub</span><span class="variable"> invalid </span><span class="operator">{</span> <span class="keyword">die</span> <span class="string">"/</span><span class="variable">$_</span><span class="string">[0]/: invalid escape '\\</span><span class="variable">$_</span><span class="string">[1]'"</span><span class="operator">}</span>
</pre>
<pre>
    <span class="comment"># We must also take care of not escaping the legitimate \\Y|</span>
    <span class="comment"># sequence, hence the presence of '\\' in the conversion rules.</span>
    <span class="keyword">my</span> <span class="variable">%rules</span> <span class="operator">=</span> <span class="operator">(</span> <span class="string">'\\'</span> <span class="operator">=&gt;</span> <span class="string">'\\\\'</span><span class="operator">,</span>
                  <span class="string">'Y|'</span> <span class="operator">=&gt;</span> <span class="string">qr/(?=\S)(?&lt;!\S)|(?!\S)(?&lt;=\S)/</span> <span class="operator">);</span>
    <span class="keyword">sub</span><span class="variable"> convert </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$re</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="variable">$re</span> <span class="operator">=~</span> <span class="regex">s{
                \\ ( \\ | Y . )
              }
              { $rules{$1} or invalid($re,$1) }sgex</span><span class="operator">;</span>
      <span class="keyword">return</span> <span class="variable">$re</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<p>Now <code>use customre</code> enables the new escape in constant regular
expressions, i.e., those without any runtime variable interpolations.
As documented in <a href="../../lib/overload.html">the overload manpage</a>, this conversion will work only over
literal parts of regular expressions.  For <code>\Y|$re\Y|</code> the variable
part of this regular expression needs to be converted explicitly
(but only if the special meaning of <code>\Y|</code> should be enabled inside $re):</p>
<pre>
    <span class="keyword">use</span> <span class="variable">customre</span><span class="operator">;</span>
    <span class="variable">$re</span> <span class="operator">=</span> <span class="operator">&lt;&gt;;</span>
    <span class="keyword">chomp</span> <span class="variable">$re</span><span class="operator">;</span>
    <span class="variable">$re</span> <span class="operator">=</span> <span class="variable">customre::convert</span> <span class="variable">$re</span><span class="operator">;</span>
    <span class="regex">/\Y|</span><span class="variable">$re</span><span class="regex">\Y|/</span><span class="operator">;</span>
</pre>
<p>
</p>
<hr />
<h1><a name="pcre_python_support">PCRE/Python Support</a></h1>
<p>As of Perl 5.10.0, Perl supports several Python/PCRE specific extensions
to the regex syntax. While Perl programmers are encouraged to use the
Perl specific syntax, the following are also accepted:</p>
<dl>
<dt><strong><a name="p_name_pattern" class="item"><code>(?P&lt;NAME&gt;pattern)</code></a></strong>

<dd>
<p>Define a named capture buffer. Equivalent to <a href="#name_pattern"><code>(?&lt;NAME&gt;pattern)</code></a>.</p>
</dd>
</li>
<dt><strong><a name="p_name" class="item"><code>(?P=NAME)</code></a></strong>

<dd>
<p>Backreference to a named capture buffer. Equivalent to <code>\g{NAME}</code>.</p>
</dd>
</li>
<dt><strong><a name="p_name2" class="item"><a href="#p_name"><code>(?P&gt;NAME)</code></a></a></strong>

<dd>
<p>Subroutine call to a named capture buffer. Equivalent to <a href="#name"><code>(?&amp;NAME)</code></a>.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="bugs">BUGS</a></h1>
<p>This document varies from difficult to understand to completely
and utterly opaque.  The wandering prose riddled with jargon is
hard to fathom in several places.</p>
<p>This document needs a rewrite that separates the tutorial content
from the reference content.</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p><a href="../../lib/pods/perlrequick.html">the perlrequick manpage</a>.</p>
<p><a href="../../lib/pods/perlretut.html">the perlretut manpage</a>.</p>
<p><a href="../../lib/pods/perlop.html#regexp_quote_like_operators">Regexp Quote-Like Operators in the perlop manpage</a>.</p>
<p><a href="../../lib/pods/perlop.html#gory_details_of_parsing_quoted_constructs">Gory details of parsing quoted constructs in the perlop manpage</a>.</p>
<p><a href="../../lib/pods/perlfaq6.html">the perlfaq6 manpage</a>.</p>
<p><a href="../../lib/pods/perlfunc.html#pos">pos in the perlfunc manpage</a>.</p>
<p><a href="../../lib/pods/perllocale.html">the perllocale manpage</a>.</p>
<p><a href="../../lib/pods/perlebcdic.html">the perlebcdic manpage</a>.</p>
<p><em>Mastering Regular Expressions</em> by Jeffrey Friedl, published
by O'Reilly and Associates.</p>

</body>

</html>
