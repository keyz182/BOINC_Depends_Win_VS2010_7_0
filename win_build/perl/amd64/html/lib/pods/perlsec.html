<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title>perlsec - Perl security</title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>


<!-- INDEX BEGIN -->
<div name="index">
<script>writelinks('__top__',2);</script>
<h1><a>perlsec - Perl security</a></h1>
<p><a name="__index__"></a></p>


<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#laundering_and_detecting_tainted_data">Laundering and Detecting Tainted Data</a></li>
		<li><a href="#switches_on_the____line">Switches On the &quot;#!&quot; Line</a></li>
		<li><a href="#taint_mode_and__inc">Taint mode and @INC</a></li>
		<li><a href="#cleaning_up_your_path">Cleaning Up Your Path</a></li>
		<li><a href="#security_bugs">Security Bugs</a></li>
		<li><a href="#protecting_your_programs">Protecting Your Programs</a></li>
		<li><a href="#unicode">Unicode</a></li>
		<li><a href="#algorithmic_complexity_attacks">Algorithmic Complexity Attacks</a></li>
	</ul>

	<li><a href="#see_also">SEE ALSO</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>perlsec - Perl security</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>Perl is designed to make it easy to program securely even when running
with extra privileges, like setuid or setgid programs.  Unlike most
command line shells, which are based on multiple substitution passes on
each line of the script, Perl uses a more conventional evaluation scheme
with fewer hidden snags.  Additionally, because the language has more
builtin functionality, it can rely less upon external (and possibly
untrustworthy) programs to accomplish its purposes.</p>
<p>Perl automatically enables a set of special security checks, called <em>taint
mode</em>, when it detects its program running with differing real and effective
user or group IDs.  The setuid bit in Unix permissions is mode 04000, the
setgid bit mode 02000; either or both may be set.  You can also enable taint
mode explicitly by using the <strong>-T</strong> command line flag. This flag is
<em>strongly</em> suggested for server programs and any program run on behalf of
someone else, such as a CGI script. Once taint mode is on, it's on for
the remainder of your script.</p>
<p>While in this mode, Perl takes special precautions called <em>taint
checks</em> to prevent both obvious and subtle traps.  Some of these checks
are reasonably simple, such as verifying that path directories aren't
writable by others; careful programmers have always used checks like
these.  Other checks, however, are best supported by the language itself,
and it is these checks especially that contribute to making a set-id Perl
program more secure than the corresponding C program.</p>
<p>You may not use data derived from outside your program to affect
something else outside your program--at least, not by accident.  All
command line arguments, environment variables, locale information (see
<a href="../../lib/pods/perllocale.html">the perllocale manpage</a>), results of certain system calls (<a href="../../lib/pods/perlfunc.html#readdir"><code>readdir()</code></a>,
<a href="../../lib/pods/perlfunc.html#readlink"><code>readlink()</code></a>, the variable of <a href="../../lib/pods/perlfunc.html#shmread"><code>shmread()</code></a>, the messages returned by
<a href="../../lib/pods/perlfunc.html#msgrcv"><code>msgrcv()</code></a>, the password, gcos and shell fields returned by the
<code>getpwxxx()</code> calls), and all file input are marked as &quot;tainted&quot;.
Tainted data may not be used directly or indirectly in any command
that invokes a sub-shell, nor in any command that modifies files,
directories, or processes, <strong>with the following exceptions</strong>:</p>
<ul>
<li>
<p>Arguments to <a href="../../lib/pods/perlfunc.html#print"><code>print</code></a> and <a href="../../lib/pods/perlfunc.html#syswrite"><code>syswrite</code></a> are <strong>not</strong> checked for taintedness.</p>
</li>
<li>
<p>Symbolic methods</p>
<pre>
    <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">$method</span><span class="operator">(</span><span class="variable">@args</span><span class="operator">);</span>
</pre>
<p>and symbolic sub references</p>
<pre>
    <span class="operator">&amp;{</span><span class="variable">$foo</span><span class="operator">}(</span><span class="variable">@args</span><span class="operator">);</span>
    <span class="variable">$foo</span><span class="operator">-&gt;(</span><span class="variable">@args</span><span class="operator">);</span>
</pre>
<p>are not checked for taintedness.  This requires extra carefulness
unless you want external data to affect your control flow.  Unless
you carefully limit what these symbolic values are, people are able
to call functions <strong>outside</strong> your Perl code, such as POSIX::system,
in which case they are able to run arbitrary external code.</p>
</li>
<li>
<p>Hash keys are <strong>never</strong> tainted.</p>
</li>
</ul>
<p>For efficiency reasons, Perl takes a conservative view of
whether data is tainted.  If an expression contains tainted data,
any subexpression may be considered tainted, even if the value
of the subexpression is not itself affected by the tainted data.</p>
<p>Because taintedness is associated with each scalar value, some
elements of an array or hash can be tainted and others not.
The keys of a hash are <strong>never</strong> tainted.</p>
<p>For example:</p>
<pre>
    <span class="variable">$arg</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>               <span class="comment"># $arg is tainted</span>
    <span class="variable">$hid</span> <span class="operator">=</span> <span class="variable">$arg</span><span class="operator">,</span> <span class="string">'bar'</span><span class="operator">;</span>         <span class="comment"># $hid is also tainted</span>
    <span class="variable">$line</span> <span class="operator">=</span> <span class="operator">&lt;&gt;;</span>                 <span class="comment"># Tainted</span>
    <span class="variable">$line</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">STDIN</span><span class="operator">&gt;;</span>            <span class="comment"># Also tainted</span>
    <span class="keyword">open</span> <span class="variable">FOO</span><span class="operator">,</span> <span class="string">"/home/me/bar"</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
    <span class="variable">$line</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">FOO</span><span class="operator">&gt;;</span>              <span class="comment"># Still tainted</span>
    <span class="variable">$path</span> <span class="operator">=</span> <span class="variable">$ENV</span><span class="operator">{</span><span class="string">'PATH'</span><span class="operator">}</span><span class="operator">;</span>       <span class="comment"># Tainted, but see below</span>
    <span class="variable">$data</span> <span class="operator">=</span> <span class="string">'abc'</span><span class="operator">;</span>              <span class="comment"># Not tainted</span>
</pre>
<pre>
    <span class="keyword">system</span> <span class="string">"echo </span><span class="variable">$arg</span><span class="string">"</span><span class="operator">;</span>         <span class="comment"># Insecure</span>
    <span class="keyword">system</span> <span class="string">"/bin/echo"</span><span class="operator">,</span> <span class="variable">$arg</span><span class="operator">;</span>   <span class="comment"># Considered insecure</span>
                                <span class="comment"># (Perl doesn't know about /bin/echo)</span>
    <span class="keyword">system</span> <span class="string">"echo </span><span class="variable">$hid</span><span class="string">"</span><span class="operator">;</span>         <span class="comment"># Insecure</span>
    <span class="keyword">system</span> <span class="string">"echo </span><span class="variable">$data</span><span class="string">"</span><span class="operator">;</span>        <span class="comment"># Insecure until PATH set</span>
</pre>
<pre>
    <span class="variable">$path</span> <span class="operator">=</span> <span class="variable">$ENV</span><span class="operator">{</span><span class="string">'PATH'</span><span class="operator">}</span><span class="operator">;</span>       <span class="comment"># $path now tainted</span>
</pre>
<pre>
    <span class="variable">$ENV</span><span class="operator">{</span><span class="string">'PATH'</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">'/bin:/usr/bin'</span><span class="operator">;</span>
    <span class="keyword">delete</span> <span class="variable">@ENV</span><span class="operator">{</span><span class="string">'IFS'</span><span class="operator">,</span> <span class="string">'CDPATH'</span><span class="operator">,</span> <span class="string">'ENV'</span><span class="operator">,</span> <span class="string">'BASH_ENV'</span><span class="operator">}</span><span class="operator">;</span>
</pre>
<pre>
    <span class="variable">$path</span> <span class="operator">=</span> <span class="variable">$ENV</span><span class="operator">{</span><span class="string">'PATH'</span><span class="operator">}</span><span class="operator">;</span>       <span class="comment"># $path now NOT tainted</span>
    <span class="keyword">system</span> <span class="string">"echo </span><span class="variable">$data</span><span class="string">"</span><span class="operator">;</span>        <span class="comment"># Is secure now!</span>
</pre>
<pre>
    <span class="keyword">open</span><span class="operator">(</span><span class="variable">FOO</span><span class="operator">,</span> <span class="string">"&lt; </span><span class="variable">$arg</span><span class="string">"</span><span class="operator">);</span>        <span class="comment"># OK - read-only file</span>
    <span class="keyword">open</span><span class="operator">(</span><span class="variable">FOO</span><span class="operator">,</span> <span class="string">"&gt; </span><span class="variable">$arg</span><span class="string">"</span><span class="operator">);</span>        <span class="comment"># Not OK - trying to write</span>
</pre>
<pre>
    <span class="keyword">open</span><span class="operator">(</span><span class="variable">FOO</span><span class="operator">,</span><span class="string">"echo </span><span class="variable">$arg</span><span class="string">|"</span><span class="operator">);</span>     <span class="comment"># Not OK</span>
    <span class="keyword">open</span><span class="operator">(</span><span class="variable">FOO</span><span class="operator">,</span><span class="string">"-|"</span><span class="operator">)</span>
        <span class="keyword">or</span> <span class="keyword">exec</span> <span class="string">'echo'</span><span class="operator">,</span> <span class="variable">$arg</span><span class="operator">;</span>   <span class="comment"># Also not OK</span>
</pre>
<pre>
    <span class="variable">$shout</span> <span class="operator">=</span> <span class="string">`echo </span><span class="variable">$arg</span><span class="string">`</span><span class="operator">;</span>       <span class="comment"># Insecure, $shout now tainted</span>
</pre>
<pre>
    <span class="keyword">unlink</span> <span class="variable">$data</span><span class="operator">,</span> <span class="variable">$arg</span><span class="operator">;</span>         <span class="comment"># Insecure</span>
    <span class="keyword">umask</span> <span class="variable">$arg</span><span class="operator">;</span>                 <span class="comment"># Insecure</span>
</pre>
<pre>
    <span class="keyword">exec</span> <span class="string">"echo </span><span class="variable">$arg</span><span class="string">"</span><span class="operator">;</span>           <span class="comment"># Insecure</span>
    <span class="keyword">exec</span> <span class="string">"echo"</span><span class="operator">,</span> <span class="variable">$arg</span><span class="operator">;</span>          <span class="comment"># Insecure</span>
    <span class="keyword">exec</span> <span class="string">"sh"</span><span class="operator">,</span> <span class="string">'-c'</span><span class="operator">,</span> <span class="variable">$arg</span><span class="operator">;</span>      <span class="comment"># Very insecure!</span>
</pre>
<pre>
    <span class="variable">@files</span> <span class="operator">=</span> <span class="operator">&lt;*.</span><span class="variable">c</span><span class="operator">&gt;;</span>             <span class="comment"># insecure (uses readdir() or similar)</span>
    <span class="variable">@files</span> <span class="operator">=</span> <span class="keyword">glob</span><span class="operator">(</span><span class="string">'*.c'</span><span class="operator">);</span>       <span class="comment"># insecure (uses readdir() or similar)</span>
</pre>
<pre>
    <span class="comment"># In Perl releases older than 5.6.0 the &lt;*.c&gt; and glob('*.c') would</span>
    <span class="comment"># have used an external program to do the filename expansion; but in</span>
    <span class="comment"># either case the result is tainted since the list of filenames comes</span>
    <span class="comment"># from outside of the program.</span>
</pre>
<pre>
    <span class="variable">$bad</span> <span class="operator">=</span> <span class="operator">(</span><span class="variable">$arg</span><span class="operator">,</span> <span class="number">23</span><span class="operator">);</span>          <span class="comment"># $bad will be tainted</span>
    <span class="variable">$arg</span><span class="operator">,</span> <span class="string">`true`</span><span class="operator">;</span>               <span class="comment"># Insecure (although it isn't really)</span>
</pre>
<p>If you try to do something insecure, you will get a fatal error saying
something like &quot;Insecure dependency&quot; or &quot;Insecure $ENV{PATH}&quot;.</p>
<p>The exception to the principle of &quot;one tainted value taints the whole
expression&quot; is with the ternary conditional operator <code>?:</code>.  Since code
with a ternary conditional</p>
<pre>
    <span class="variable">$result</span> <span class="operator">=</span> <span class="variable">$tainted_value</span> <span class="operator">?</span> <span class="string">"Untainted"</span> <span class="operator">:</span> <span class="string">"Also untainted"</span><span class="operator">;</span>
</pre>
<p>is effectively</p>
<pre>
    <span class="keyword">if</span> <span class="operator">(</span> <span class="variable">$tainted_value</span> <span class="operator">)</span> <span class="operator">{</span>
        <span class="variable">$result</span> <span class="operator">=</span> <span class="string">"Untainted"</span><span class="operator">;</span>
    <span class="operator">}</span> <span class="keyword">else</span> <span class="operator">{</span>
        <span class="variable">$result</span> <span class="operator">=</span> <span class="string">"Also untainted"</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<p>it doesn't make sense for <code>$result</code> to be tainted.</p>
<p>
</p>
<h2><a name="laundering_and_detecting_tainted_data">Laundering and Detecting Tainted Data</a></h2>
<p>To test whether a variable contains tainted data, and whose use would
thus trigger an &quot;Insecure dependency&quot; message, you can use the
<code>tainted()</code> function of the Scalar::Util module, available in your
nearby CPAN mirror, and included in Perl starting from the release 5.8.0.
Or you may be able to use the following <code>is_tainted()</code> function.</p>
<pre>
    <span class="keyword">sub</span><span class="variable"> is_tainted </span><span class="operator">{</span>
        <span class="keyword">return</span> <span class="operator">!</span> <span class="keyword">eval</span> <span class="operator">{</span> <span class="keyword">eval</span><span class="operator">(</span><span class="string">"#"</span> <span class="operator">.</span> <span class="keyword">substr</span><span class="operator">(</span><span class="keyword">join</span><span class="operator">(</span><span class="string">""</span><span class="operator">,</span> <span class="variable">@_</span><span class="operator">),</span> <span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">));</span> <span class="number">1</span> <span class="operator">};</span>
    <span class="operator">}</span>
</pre>
<p>This function makes use of the fact that the presence of tainted data
anywhere within an expression renders the entire expression tainted.  It
would be inefficient for every operator to test every argument for
taintedness.  Instead, the slightly more efficient and conservative
approach is used that if any tainted value has been accessed within the
same expression, the whole expression is considered tainted.</p>
<p>But testing for taintedness gets you only so far.  Sometimes you have just
to clear your data's taintedness.  Values may be untainted by using them
as keys in a hash; otherwise the only way to bypass the tainting
mechanism is by referencing subpatterns from a regular expression match.
Perl presumes that if you reference a substring using $1, $2, etc., that
you knew what you were doing when you wrote the pattern.  That means using
a bit of thought--don't just blindly untaint anything, or you defeat the
entire mechanism.  It's better to verify that the variable has only good
characters (for certain values of &quot;good&quot;) rather than checking whether it
has any bad characters.  That's because it's far too easy to miss bad
characters that you never thought of.</p>
<p>Here's a test to make sure that the data contains nothing but &quot;word&quot;
characters (alphabetics, numerics, and underscores), a hyphen, an at sign,
or a dot.</p>
<pre>
    <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$data</span> <span class="operator">=~</span> <span class="regex">/^([-\@\w.]+)$/</span><span class="operator">)</span> <span class="operator">{</span>
        <span class="variable">$data</span> <span class="operator">=</span> <span class="variable">$1</span><span class="operator">;</span>                     <span class="comment"># $data now untainted</span>
    <span class="operator">}</span> <span class="keyword">else</span> <span class="operator">{</span>
        <span class="keyword">die</span> <span class="string">"Bad data in '</span><span class="variable">$data</span><span class="string">'"</span><span class="operator">;</span>      <span class="comment"># log this somewhere</span>
    <span class="operator">}</span>
</pre>
<p>This is fairly secure because <a href="../../lib/pods/perlrun.html#w"><code>/\w+/</code></a> doesn't normally match shell
metacharacters, nor are dot, dash, or at going to mean something special
to the shell.  Use of <code>/.+/</code> would have been insecure in theory because
it lets everything through, but Perl doesn't check for that.  The lesson
is that when untainting, you must be exceedingly careful with your patterns.
Laundering data using regular expression is the <em>only</em> mechanism for
untainting dirty data, unless you use the strategy detailed below to fork
a child of lesser privilege.</p>
<p>The example does not untaint <code>$data</code> if <code>use locale</code> is in effect,
because the characters matched by <a href="../../lib/pods/perlrun.html#w"><code>\w</code></a> are determined by the locale.
Perl considers that locale definitions are untrustworthy because they
contain data from outside the program.  If you are writing a
locale-aware program, and want to launder data with a regular expression
containing <a href="../../lib/pods/perlrun.html#w"><code>\w</code></a>, put <code>no locale</code> ahead of the expression in the same
block.  See <a href="../../lib/pods/perllocale.html#security">SECURITY in the perllocale manpage</a> for further discussion and examples.</p>
<p>
</p>
<h2><a name="switches_on_the____line">Switches On the &quot;#!&quot; Line</a></h2>
<p>When you make a script executable, in order to make it usable as a
command, the system will pass switches to perl from the script's #!
line.  Perl checks that any command line switches given to a setuid
(or setgid) script actually match the ones set on the #! line.  Some
Unix and Unix-like environments impose a one-switch limit on the #!
line, so you may need to use something like <code>-wU</code> instead of <code>-w -U</code>
under such systems.  (This issue should arise only in Unix or
Unix-like environments that support #! and setuid or setgid scripts.)</p>
<p>
</p>
<h2><a name="taint_mode_and__inc">Taint mode and @INC</a></h2>
<p>When the taint mode (<a href="../../lib/pods/perlrun.html#t"><code>-T</code></a>) is in effect, the &quot;.&quot; directory is removed
from <a href="../../lib/pods/perlvar.html#_inc"><code>@INC</code></a>, and the environment variables <a href="../../lib/pods/perlrun.html#perl5lib"><code>PERL5LIB</code></a> and <a href="../../lib/pods/perlrun.html#perllib"><code>PERLLIB</code></a>
are ignored by Perl. You can still adjust <a href="../../lib/pods/perlvar.html#_inc"><code>@INC</code></a> from outside the
program by using the <code>-I</code> command line option as explained in
<a href="../../lib/pods/perlrun.html">the perlrun manpage</a>. The two environment variables are ignored because
they are obscured, and a user running a program could be unaware that
they are set, whereas the <code>-I</code> option is clearly visible and
therefore permitted.</p>
<p>Another way to modify <a href="../../lib/pods/perlvar.html#_inc"><code>@INC</code></a> without modifying the program, is to use
the <code>lib</code> pragma, e.g.:</p>
<pre>
  perl -Mlib=/foo program</pre>
<p>The benefit of using <code>-Mlib=/foo</code> over <code>-I/foo</code>, is that the former
will automagically remove any duplicated directories, while the later
will not.</p>
<p>Note that if a tainted string is added to <a href="../../lib/pods/perlvar.html#_inc"><code>@INC</code></a>, the following
problem will be reported:</p>
<pre>
  Insecure dependency in require while running with -T switch</pre>
<p>
</p>
<h2><a name="cleaning_up_your_path">Cleaning Up Your Path</a></h2>
<p>For &quot;Insecure <code>$ENV{PATH}</code>&quot; messages, you need to set <code>$ENV{'PATH'}</code> to
a known value, and each directory in the path must be absolute and
non-writable by others than its owner and group.  You may be surprised to
get this message even if the pathname to your executable is fully
qualified.  This is <em>not</em> generated because you didn't supply a full path
to the program; instead, it's generated because you never set your PATH
environment variable, or you didn't set it to something that was safe.
Because Perl can't guarantee that the executable in question isn't itself
going to turn around and execute some other program that is dependent on
your PATH, it makes sure you set the PATH.</p>
<p>The PATH isn't the only environment variable which can cause problems.
Because some shells may use the variables IFS, CDPATH, ENV, and
BASH_ENV, Perl checks that those are either empty or untainted when
starting subprocesses. You may wish to add something like this to your
setid and taint-checking scripts.</p>
<pre>
    <span class="keyword">delete</span> <span class="variable">@ENV</span><span class="operator">{</span><span class="string">qw(IFS CDPATH ENV BASH_ENV)</span><span class="operator">}</span><span class="operator">;</span>   <span class="comment"># Make %ENV safer</span>
</pre>
<p>It's also possible to get into trouble with other operations that don't
care whether they use tainted values.  Make judicious use of the file
tests in dealing with any user-supplied filenames.  When possible, do
opens and such <strong>after</strong> properly dropping any special user (or group!)
privileges. Perl doesn't prevent you from opening tainted filenames for reading,
so be careful what you print out.  The tainting mechanism is intended to
prevent stupid mistakes, not to remove the need for thought.</p>
<p>Perl does not call the shell to expand wild cards when you pass <a href="../../lib/pods/perlfunc.html#system"><code>system</code></a>
and <a href="../../lib/pods/perlfunc.html#exec"><code>exec</code></a> explicit parameter lists instead of strings with possible shell
wildcards in them.  Unfortunately, the <a href="../../lib/pods/perlfunc.html#open"><code>open</code></a>, <a href="../../lib/pods/perlfunc.html#glob"><code>glob</code></a>, and
backtick functions provide no such alternate calling convention, so more
subterfuge will be required.</p>
<p>Perl provides a reasonably safe way to open a file or pipe from a setuid
or setgid program: just create a child process with reduced privilege who
does the dirty work for you.  First, fork a child using the special
<a href="../../lib/pods/perlfunc.html#open"><code>open</code></a> syntax that connects the parent and child by a pipe.  Now the
child resets its ID set and any other per-process attributes, like
environment variables, umasks, current working directories, back to the
originals or known safe values.  Then the child process, which no longer
has any special permissions, does the <a href="../../lib/pods/perlfunc.html#open"><code>open</code></a> or other system call.
Finally, the child passes the data it managed to access back to the
parent.  Because the file or pipe was opened in the child while running
under less privilege than the parent, it's not apt to be tricked into
doing something it shouldn't.</p>
<p>Here's a way to do backticks reasonably safely.  Notice how the <a href="../../lib/pods/perlfunc.html#exec"><code>exec</code></a> is
not called with a string that the shell could expand.  This is by far the
best way to call something that might be subjected to shell escapes: just
never call the shell at all.</p>
<pre>
        <span class="keyword">use</span> <span class="variable">English</span> <span class="string">'-no_match_vars'</span><span class="operator">;</span>
        <span class="keyword">die</span> <span class="string">"Can't fork: $!"</span> <span class="keyword">unless</span> <span class="keyword">defined</span><span class="operator">(</span><span class="variable">$pid</span> <span class="operator">=</span> <span class="keyword">open</span><span class="operator">(</span><span class="variable">KID</span><span class="operator">,</span> <span class="string">"-|"</span><span class="operator">));</span>
        <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$pid</span><span class="operator">)</span> <span class="operator">{</span>           <span class="comment"># parent</span>
            <span class="keyword">while</span> <span class="operator">(&lt;</span><span class="variable">KID</span><span class="operator">&gt;)</span> <span class="operator">{</span>
                <span class="comment"># do something</span>
            <span class="operator">}</span>
            <span class="keyword">close</span> <span class="variable">KID</span><span class="operator">;</span>
        <span class="operator">}</span> <span class="keyword">else</span> <span class="operator">{</span>
            <span class="keyword">my</span> <span class="variable">@temp</span>     <span class="operator">=</span> <span class="operator">(</span><span class="variable">$EUID</span><span class="operator">,</span> <span class="variable">$EGID</span><span class="operator">);</span>
            <span class="keyword">my</span> <span class="variable">$orig_uid</span> <span class="operator">=</span> <span class="variable">$UID</span><span class="operator">;</span>
            <span class="keyword">my</span> <span class="variable">$orig_gid</span> <span class="operator">=</span> <span class="variable">$GID</span><span class="operator">;</span>
            <span class="variable">$EUID</span> <span class="operator">=</span> <span class="variable">$UID</span><span class="operator">;</span>
            <span class="variable">$EGID</span> <span class="operator">=</span> <span class="variable">$GID</span><span class="operator">;</span>
            <span class="comment"># Drop privileges</span>
            <span class="variable">$UID</span>  <span class="operator">=</span> <span class="variable">$orig_uid</span><span class="operator">;</span>
            <span class="variable">$GID</span>  <span class="operator">=</span> <span class="variable">$orig_gid</span><span class="operator">;</span>
            <span class="comment"># Make sure privs are really gone</span>
            <span class="operator">(</span><span class="variable">$EUID</span><span class="operator">,</span> <span class="variable">$EGID</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@temp</span><span class="operator">;</span>
            <span class="keyword">die</span> <span class="string">"Can't drop privileges"</span>
                <span class="keyword">unless</span> <span class="variable">$UID</span> <span class="operator">==</span> <span class="variable">$EUID</span>  <span class="operator">&amp;&amp;</span> <span class="variable">$GID</span> <span class="keyword">eq</span> <span class="variable">$EGID</span><span class="operator">;</span>
            <span class="variable">$ENV</span><span class="operator">{</span><span class="string">PATH</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">"/bin:/usr/bin"</span><span class="operator">;</span> <span class="comment"># Minimal PATH.</span>
            <span class="comment"># Consider sanitizing the environment even more.</span>
            <span class="keyword">exec</span> <span class="string">'myprog'</span><span class="operator">,</span> <span class="string">'arg1'</span><span class="operator">,</span> <span class="string">'arg2'</span>
                <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"can't exec myprog: $!"</span><span class="operator">;</span>
        <span class="operator">}</span>
</pre>
<p>A similar strategy would work for wildcard expansion via <a href="../../lib/pods/perlfunc.html#glob"><code>glob</code></a>, although
you can use <a href="../../lib/pods/perlfunc.html#readdir"><code>readdir</code></a> instead.</p>
<p>Taint checking is most useful when although you trust yourself not to have
written a program to give away the farm, you don't necessarily trust those
who end up using it not to try to trick it into doing something bad.  This
is the kind of security checking that's useful for set-id programs and
programs launched on someone else's behalf, like CGI programs.</p>
<p>This is quite different, however, from not even trusting the writer of the
code not to try to do something evil.  That's the kind of trust needed
when someone hands you a program you've never seen before and says, &quot;Here,
run this.&quot;  For that kind of safety, check out the Safe module,
included standard in the Perl distribution.  This module allows the
programmer to set up special compartments in which all system operations
are trapped and namespace access is carefully controlled.</p>
<p>
</p>
<h2><a name="security_bugs">Security Bugs</a></h2>
<p>Beyond the obvious problems that stem from giving special privileges to
systems as flexible as scripts, on many versions of Unix, set-id scripts
are inherently insecure right from the start.  The problem is a race
condition in the kernel.  Between the time the kernel opens the file to
see which interpreter to run and when the (now-set-id) interpreter turns
around and reopens the file to interpret it, the file in question may have
changed, especially if you have symbolic links on your system.</p>
<p>Fortunately, sometimes this kernel &quot;feature&quot; can be disabled.
Unfortunately, there are two ways to disable it.  The system can simply
outlaw scripts with any set-id bit set, which doesn't help much.
Alternately, it can simply ignore the set-id bits on scripts.  If the
latter is true, Perl can emulate the setuid and setgid mechanism when it
notices the otherwise useless setuid/gid bits on Perl scripts.  It does
this via a special executable called <em class="file">suidperl</em> that is automatically
invoked for you if it's needed.</p>
<p>However, if the kernel set-id script feature isn't disabled, Perl will
complain loudly that your set-id script is insecure.  You'll need to
either disable the kernel set-id script feature, or put a C wrapper around
the script.  A C wrapper is just a compiled program that does nothing
except call your Perl program.   Compiled programs are not subject to the
kernel bug that plagues set-id scripts.  Here's a simple wrapper, written
in C:</p>
<pre>
    <span class="comment">#define REAL_PATH "/path/to/script"</span>
    <span class="variable">main</span><span class="operator">(</span><span class="variable">ac</span><span class="operator">,</span> <span class="variable">av</span><span class="operator">)</span>
        <span class="variable">char</span> <span class="operator">**</span><span class="variable">av</span><span class="operator">;</span>
    <span class="operator">{</span>
        <span class="variable">execv</span><span class="operator">(</span><span class="variable">REAL_PATH</span><span class="operator">,</span> <span class="variable">av</span><span class="operator">);</span>
    <span class="operator">}</span>
</pre>
<p>Compile this wrapper into a binary executable and then make <em>it</em> rather
than your script setuid or setgid.</p>
<p>In recent years, vendors have begun to supply systems free of this
inherent security bug.  On such systems, when the kernel passes the name
of the set-id script to open to the interpreter, rather than using a
pathname subject to meddling, it instead passes <em>/dev/fd/3</em>.  This is a
special file already opened on the script, so that there can be no race
condition for evil scripts to exploit.  On these systems, Perl should be
compiled with <code>-DSETUID_SCRIPTS_ARE_SECURE_NOW</code>.  The <em class="file">Configure</em>
program that builds Perl tries to figure this out for itself, so you
should never have to specify this yourself.  Most modern releases of
SysVr4 and BSD 4.4 use this approach to avoid the kernel race condition.</p>
<p>Prior to release 5.6.1 of Perl, bugs in the code of <em class="file">suidperl</em> could
introduce a security hole.</p>
<p>
</p>
<h2><a name="protecting_your_programs">Protecting Your Programs</a></h2>
<p>There are a number of ways to hide the source to your Perl programs,
with varying levels of &quot;security&quot;.</p>
<p>First of all, however, you <em>can't</em> take away read permission, because
the source code has to be readable in order to be compiled and
interpreted.  (That doesn't mean that a CGI script's source is
readable by people on the web, though.)  So you have to leave the
permissions at the socially friendly 0755 level.  This lets 
people on your local system only see your source.</p>
<p>Some people mistakenly regard this as a security problem.  If your program does
insecure things, and relies on people not knowing how to exploit those
insecurities, it is not secure.  It is often possible for someone to
determine the insecure things and exploit them without viewing the
source.  Security through obscurity, the name for hiding your bugs
instead of fixing them, is little security indeed.</p>
<p>You can try using encryption via source filters (Filter::* from CPAN,
or Filter::Util::Call and Filter::Simple since Perl 5.8).
But crackers might be able to decrypt it.  You can try using the byte
code compiler and interpreter described below, but crackers might be
able to de-compile it.  You can try using the native-code compiler
described below, but crackers might be able to disassemble it.  These
pose varying degrees of difficulty to people wanting to get at your
code, but none can definitively conceal it (this is true of every
language, not just Perl).</p>
<p>If you're concerned about people profiting from your code, then the
bottom line is that nothing but a restrictive licence will give you
legal security.  License your software and pepper it with threatening
statements like &quot;This is unpublished proprietary software of XYZ Corp.
Your access to it does not give you permission to use it blah blah
blah.&quot;  You should see a lawyer to be sure your licence's wording will
stand up in court.</p>
<p>
</p>
<h2><a name="unicode">Unicode</a></h2>
<p>Unicode is a new and complex technology and one may easily overlook
certain security pitfalls.  See <a href="../../lib/pods/perluniintro.html">the perluniintro manpage</a> for an overview and
<a href="../../lib/pods/perlunicode.html">the perlunicode manpage</a> for details, and <a href="../../lib/pods/perlunicode.html#security_implications_of_unicode">Security Implications of Unicode in the perlunicode manpage</a> for security implications in particular.</p>
<p>
</p>
<h2><a name="algorithmic_complexity_attacks">Algorithmic Complexity Attacks</a></h2>
<p>Certain internal algorithms used in the implementation of Perl can
be attacked by choosing the input carefully to consume large amounts
of either time or space or both.  This can lead into the so-called
<em>Denial of Service</em> (DoS) attacks.</p>
<ul>
<li>
<p>Hash Function - the algorithm used to &quot;order&quot; hash elements has been
changed several times during the development of Perl, mainly to be
reasonably fast.  In Perl 5.8.1 also the security aspect was taken
into account.</p>
<p>In Perls before 5.8.1 one could rather easily generate data that as
hash keys would cause Perl to consume large amounts of time because
internal structure of hashes would badly degenerate.  In Perl 5.8.1
the hash function is randomly perturbed by a pseudorandom seed which
makes generating such naughty hash keys harder.
See <a href="../../lib/pods/perlrun.html#perl_hash_seed">PERL_HASH_SEED in the perlrun manpage</a> for more information.</p>
<p>The random perturbation is done by default but if one wants for some
reason emulate the old behaviour one can set the environment variable
PERL_HASH_SEED to zero (or any other integer).  One possible reason
for wanting to emulate the old behaviour is that in the new behaviour
consecutive runs of Perl will order hash keys differently, which may
confuse some applications (like Data::Dumper: the outputs of two
different runs are no more identical).</p>
<p><strong>Perl has never guaranteed any ordering of the hash keys</strong>, and the
ordering has already changed several times during the lifetime of
Perl 5.  Also, the ordering of hash keys has always been, and
continues to be, affected by the insertion order.</p>
<p>Also note that while the order of the hash elements might be
randomised, this &quot;pseudoordering&quot; should <strong>not</strong> be used for
applications like shuffling a list randomly (use List::Util::shuffle()
for that, see <a href="../../lib/List/Util.html">the List::Util manpage</a>, a standard core module since Perl 5.8.0;
or the CPAN module Algorithm::Numerical::Shuffle), or for generating
permutations (use e.g. the CPAN modules Algorithm::Permute or
Algorithm::FastPermute), or for any cryptographic applications.</p>
</li>
<li>
<p>Regular expressions - Perl's regular expression engine is so called NFA
(Non-deterministic Finite Automaton), which among other things means that
it can rather easily consume large amounts of both time and space if the
regular expression may match in several ways.  Careful crafting of the
regular expressions can help but quite often there really isn't much
one can do (the book &quot;Mastering Regular Expressions&quot; is required
reading, see <a href="../../lib/pods/perlfaq2.html">the perlfaq2 manpage</a>).  Running out of space manifests itself by
Perl running out of memory.</p>
</li>
<li>
<p>Sorting - the quicksort algorithm used in Perls before 5.8.0 to
implement the <a href="../../lib/pods/perlfunc.html#sort"><code>sort()</code></a> function is very easy to trick into misbehaving
so that it consumes a lot of time.  Nothing more is required than
resorting a list already sorted.  Starting from Perl 5.8.0 a different
sorting algorithm, mergesort, is used.  Mergesort is insensitive to
its input data, so it cannot be similarly fooled.</p>
</li>
</ul>
<p>See <a href="http://www.cs.rice.edu/~scrosby/hash/">http://www.cs.rice.edu/~scrosby/hash/</a> for more information,
and any computer science textbook on the algorithmic complexity.</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p><a href="../../lib/pods/perlrun.html">the perlrun manpage</a> for its description of cleaning up environment variables.</p>

</body>

</html>
